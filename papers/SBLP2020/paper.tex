\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{graphicx}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{ifpdf}
\usepackage{mathtools}
\usepackage{semantic}

\ifpdf
\usepackage{hyperref}
\fi
\usepackage{float}
\usepackage{proof}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}


\acmConference[SBLP '20]{SBLP '20: Brazilian Symposium on Programming Languages}{October 19--23, 2020}{Natal, Brazil}
\acmBooktitle{SBLP '20: Brazilian Symposium on Programming Languages,
  October 19--23, 2020, Natal, Brazil}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% color formatting stuff %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{Example}{Example}

\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff



%%%%%%%%%%%%%%%%%%%%
%% lhs2TeX stuff  %%
%%%%%%%%%%%%%%%%%%%%


%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\Con}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%
%% Title and authors %%
%%%%%%%%%%%%%%%%%%%%%%%



\title{A Certified Interpreter for the List Machine Benchmark}

\author{Samuel Feitosa}
\authornotemark[1]
\email{samuel.feitosa@ifsc.edu.br}
\affiliation{%
  \institution{Departamento de Informática}
  \streetaddress{Instituto Federal de Santa Catarina}
  \city{Caçador}
  \state{Santa Catarina}
  \country{Brazil}
}

\author{Rodrigo Ribeiro}
\email{rodrigo.ribeiro@ufop.edu.br}
\affiliation{%
  \institution{Prog. Pós Graduação em Ciência da Computação}
  \streetaddress{Universidade Federal de Ouro Preto}
  \city{Ouro Preto}
  \state{Minas Gerais}
  \country{Brazil}}


%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract          %%
%%%%%%%%%%%%%%%%%%%%%%%



\begin{abstract}
Formal models are important tools in the programming languages research
community. However, such models are full of intrincacies and, due to that,
they are subject to subtle errors. Such failures motivated the usage of
tools to ensure the correctness of these formalisms. One way to eliminate
such errors is to encode models in a dependently-typed language in order
to ensure its ``correctness-by-construction''.

In this work, we use this idea to build a verified interpreter
for the list machine benchmark in the Agda programming language.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%
%% ACM codes for areas %%
%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{CCSXML}\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\V{ccs2012>}{}\<[E]%
\\
\>[B]{}\V{concept>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 id>10011007.10011006.10011039.10011311</concept\char95 id>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 desc>Software}\;\V{and}\;\V{its}\;\V{engineering\char126 Semantics</concept\char95 desc>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 significance>500</concept\char95 significance>}{}\<[E]%
\\
\>[B]{}\V{/concept>}{}\<[E]%
\\
\>[B]{}\V{concept>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 id>10011007.10011006.10011041.10010943</concept\char95 id>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 desc>Software}\;\V{and}\;\V{its}\;\V{engineering\char126 Interpreters</concept\char95 desc>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 significance>500</concept\char95 significance>}{}\<[E]%
\\
\>[B]{}\V{/concept>}{}\<[E]%
\\
\>[B]{}\V{concept>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 id>10003752.10003790.10011740</concept\char95 id>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 desc>Theory}\;\V{of}\;\V{computation\char126 Type}\;\V{theory</concept\char95 desc>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 significance>500</concept\char95 significance>}{}\<[E]%
\\
\>[B]{}\V{/concept>}{}\<[E]%
\\
\>[B]{}\V{/ccs2012>}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Semantics}
\ccsdesc[500]{Software and its engineering~Interpreters}
\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Dependent types, formal semantics}

\maketitle



%%%%%%%%%%%%%%%%%%%%%%%
%% Introduction      %%
%%%%%%%%%%%%%%%%%%%%%%%



\section{Introduction}

The development of a new programming language design, linguistic construct
or type system involves its careful formalization in order to express
its core ideas in a concise way. However, such models have many details
and complexities which can hinders its correctness assurances.
Because of such problems, the programming languages research community
started to use tools, like proof assistants~\cite{Stump16,Chlipala13},
and benchmark problems to validate them and stress its suitability for
such specification tasks~\cite{Aydemir05,Pientka18,Appel07}.

A popular approach for specifying formal semantics is the
use of definitional interpreters, which represents the meaning of a
programming language as an interpreter written in some
meta-language~\cite{Reynolds72}. A major advantage of such approach
is the possibility of validating the semantics through execution.
Recently, definitional interpreters were used to formalize type
soundness theorems for some advanced typing features~\cite{Amin17}
and the semantics of imperative programming languages in which static
semantics is ensured by dependently-typed
syntax\footnote{Also known as intrinsically-typed.}~\cite{Poulsen18}.
In this work, we follow Poulsen et. al and use an intrinsically-typed
representation to build a definitional interpreter for a low-level virtual
machine developed by Appel and Leroy as a benchmark problem closer to
real-world implementations like typed assembly languages~\cite{CraryM99} and
proof carrying code~\cite{Necula97}.

More specifically, we contribute:

\begin{itemize}
  \item We show how all the details of the list machine type system
        can be encoded as dependently-typed syntax which avoids, by construction,
        the presence of stuck states in its definitional interpreter.
  \item We provide a provably correct implementations for testing the subtyping
        relation and to calculate the least common super type of two input
        types for the machine registers.
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{sec:agda}
presents a brief introduction to Agda and Section~\ref{sec:list}
reviews the list machine benchmark and presents its syntax and type system.
We describe the intrinsically-typed representation for the list machine syntax,
the subtyping relation and the least common super type algorithm in
Section~\ref{sec:typing}. The list machine semantics and its realization as
a definitional interpreter are presented in Section~\ref{sec:semantics}.
Related work is discussed in Section~\ref{sec:related},
and Section~\ref{sec:conclusion} concludes.

All the source code in this article has been formalized in Agda
version 2.6.1 using Standard Library 1.3. All source code produced,
including the \LaTeX~source of this article, are available
on-line~\cite{list-rep}.


%%%%%%%%%%%%%%%%%%%%%%%
%% Overview of Agda  %%
%%%%%%%%%%%%%%%%%%%%%%%



\section{An Overview of Agda}\label{sec:agda}


Agda is a dependently-typed functional programming language based on
Martin-L\"of intuitionistic type theory~\cite{Lof98}.  Function types
and an infinite hierarchy of types of types, \ensuremath{\D{Set}\;\V{l}}, where \ensuremath{\V{l}} is a
natural number, are built-in. Everything else is a user-defined
type. The type \ensuremath{\D{Set}}, also known as \ensuremath{\D{Set}_{\D{0}}}, is the type of all
``small'' types, such as \ensuremath{\D{Bool}}, \ensuremath{\D{String}} and \ensuremath{\D{List}\;\D{Bool}}.  The type
\ensuremath{\D{Set}_{\D{1}}} is the type of \ensuremath{\D{Set}} and ``others like it'', such as \ensuremath{\D{Set}\;\to \;\D{Bool}}, \ensuremath{\D{String}\;\to \;\D{Set}}, and \ensuremath{\D{Set}\;\to \;\D{Set}}. We have that \ensuremath{\D{Set}\;\V{l}} is an
element of the type \ensuremath{\D{Set}\;(\V{l+1})}, for every $l \geq 0$. This
stratification of types is used to keep Agda consistent as a logical
theory~\cite{Sorensen2006}.

An ordinary (non-dependent) function type is written \ensuremath{\V{A}\;\to \;\V{B}} and a
dependent one is written \ensuremath{(\V{x}\;\mathbin{:}\;\V{A})\;\to \;\V{B}}, where type \ensuremath{\V{B}} depends on
\ensuremath{\V{x}}, or \ensuremath{\D{\forall}\;(\V{x}\;\mathbin{:}\;\V{A})\;\to \;\V{B}}. Agda allows the definition of \emph{implicit
parameters}, i.e.,  parameters whose values can be inferred from the
context, by surrounding them in curly braces: \ensuremath{\D{\forall}\;\{\mskip1.5mu \V{x}\;\mathbin{:}\;\V{A}\mskip1.5mu\}\;\to \;\V{B}}. To
avoid clutter, we'll omit implicit arguments from the source code
presentation. The reader can safely assume that every free variable in
a type is an implicit parameter.

As an example of Agda code, consider the following data type of
length-indexed lists, also known as vectors.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{\mathbb{N}}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{zero}\;\mathbin{:}\;\D{\mathbb{N}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{suc}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{\mathbb{N}}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathkw{data}\;\D{Vec}\;(\V{A}\;\mathbin{:}\;\D{Set})\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{\lbrack\:\rbrack}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\D{Vec}\;\V{A}\;\Con{zero}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\V{A}\;\to \;\D{Vec}\;\V{A}\;\V{n}\;\to \;\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Constructor \ensuremath{\Con{\lbrack\:\rbrack}} builds empty vectors. The cons-operator (\ensuremath{\Con{\_::\_}})
inserts a new element in front of a vector of $n$ elements (of type
\ensuremath{\D{Vec}\;\V{A}\;\V{n}}) and returns a value of type \ensuremath{\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})}. The
\ensuremath{\D{Vec}} datatype is an example of a dependent type, i.e., a type
that uses a value (that denotes its length). The usefulness of
dependent types can be illustrated with the definition of a safe list
head function: \ensuremath{\F{head}} can be defined to accept only non-empty
vectors, i.e.,~values of type \ensuremath{\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{head}\;\mathbin{:}\;\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})\;\to \;\V{A}{}\<[E]%
\\
\>[3]{}\F{head}\;(\V{x}\;\Con{::}\;\V{xs})\;\mathrel{=}\;\V{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In \ensuremath{\F{head}}'s definition, constructor \ensuremath{\Con{\lbrack\:\rbrack}} is not used. The
Agda type-checker can figure out, from \ensuremath{\F{head}}'s parameter type,
that argument \ensuremath{\Con{\lbrack\:\rbrack}} to \ensuremath{\F{head}} is not type-correct.



Another useful data type is the finite type,
\ensuremath{\D{Fin}}\footnote{Note that Agda supports the overloading of
data type constructor names. Constructor \ensuremath{\Con{zero}} can refer to
type \ensuremath{\D{\mathbb{N}}} or \ensuremath{\D{Fin}}, depending on the context where the name
is used.}, which is defined in Agda's standard library as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{Fin}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{zero}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;(\Con{suc}\;\V{n}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{suc}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{Fin}\;(\Con{suc}\;\V{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Type \ensuremath{\D{Fin}\;\V{n}} has exactly \ensuremath{\V{n}} inhabitants
(elements), i.e., it is isomorphic to the set $\{0,...,n - 1\}$.
An application of such type is to define a safe vector
lookup function, which avoids the access of invalid positions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{lookup}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{A}\;\V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{Vec}\;\V{A}\;\V{n}\;\to \;\V{A}{}\<[E]%
\\
\>[3]{}\F{lookup}\;\Con{zero}\;(\V{x}\;\Con{::}\;\anonymous )\;\mathrel{=}\;\V{x}{}\<[E]%
\\
\>[3]{}\F{lookup}\;(\Con{suc}\;\V{idx})\;(\anonymous \;\Con{::}\;\V{xs})\;\mathrel{=}\;\F{lookup}\;\V{idx}\;\V{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Thanks to the propositions-as-types principle,\footnote{It is also known as
  Curry-Howard ``isomorphism''~\cite{Sorensen2006}.} we can interpret
types as logical formulas and terms as proofs. An example is the
representation of equality as the following Agda type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{\_ \equiv \_}\;\{\mskip1.5mu \V{l}\mskip1.5mu\}\;\{\mskip1.5mu \V{A}\;\mathbin{:}\;\D{Set}\;\V{l}\mskip1.5mu\}\;(\V{x}\;\mathbin{:}\;\V{A})\;\mathbin{:}\;\V{A}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{refl}\;\mathbin{:}\;\V{x}\;\D{\equiv}\;\V{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This type is called propositional equality. It defines that there is
a unique evidence for equality, constructor \ensuremath{\Con{refl}} (for reflexivity),
that asserts that the only value equal to \ensuremath{\V{x}} is itself. Given a predicate \ensuremath{\V{P}\;\mathbin{:}\;\V{A}\;\to \;\D{Set}}
and a vector \ensuremath{\V{xs}}, the type \ensuremath{\D{All}\;\V{P}\;\V{xs}} is used to build proofs that \ensuremath{\V{P}} holds for all
elements in \ensuremath{\V{xs}} and it is defined as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{All}\;(\V{P}\;\mathbin{:}\;\V{A}\;\to \;\D{Set})\;\mathbin{:}\;\D{Vec}\;\V{A}\;\V{n}\;\to \;{}\<[41]%
\>[41]{}\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Con{\lbrack\:\rbrack}\;\mathbin{:}\;\D{All}\;\V{P}\;\Con{\lbrack\:\rbrack}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{x}\;\V{xs}\mskip1.5mu\}\;\to \;\V{P}\;\V{x}\;\to \;\D{All}\;\V{P}\;\V{xs}\;\to \;\D{All}\;\V{P}\;(\V{x}\;\Con{::}\;\V{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The first constructor specifies that \ensuremath{\D{All}\;\V{P}} holds for the empty vector and
constructor \ensuremath{\Con{\_::\_}} builds a proof of \ensuremath{\D{All}\;\V{P}\;(\V{x}\;\Con{::}\;\V{xs})} from proofs of
\ensuremath{\V{P}\;\V{x}} and \ensuremath{\D{All}\;\V{P}\;\V{xs}}. Since this type has the same structure of vectors,
some functions on \ensuremath{\D{Vec}} have similar definitions for type \ensuremath{\D{All}}. As an example
used in our formalization, consider the function \ensuremath{\F{lookup}}, which extracts a
proof of \ensuremath{\V{P}} for the element at position \ensuremath{\V{v}\;\mathbin{:}\;\D{Fin}\;\V{n}} in a \ensuremath{\D{Vec}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\F{lookup}\;\mathbin{:}\;\{\mskip1.5mu \V{xs}\;\mathbin{:}\;\D{Vec}\;\V{A}\;\V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{All}\;\V{P}\;\V{xs}\;\to \;\V{P}\;\V{x}{}\<[E]%
\\
\>[4]{}\F{lookup}\;\Con{zero}\;(\V{px}\;\Con{::}\;\anonymous )\;\mathrel{=}\;\V{px}{}\<[E]%
\\
\>[4]{}\F{lookup}\;(\Con{suc}\;\V{idx})\;(\anonymous \;\Con{::}\;\V{pxs})\;\mathrel{=}\;\F{lookup}\;\V{idx}\;\V{pxs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
An important application of dependent types is to encode programming languages
syntax. The role of dependent types in this domain is to encode programs that
only allow well-typed and well-scoped terms~\cite{Benton2012}. Intuitively, we encode
the static semantics of the object language in the host language AST's
constructor, leaving the responsibility of checking type safety to the
host's language type checker. As an example, consider the following simple
expression language.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{Expr}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{True}\;\Con{False}\;\mathbin{:}\;\D{Expr}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Num}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Expr}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_\land\_}\;\Con{\_+\_}\;\mathbin{:}\;\D{Expr}\;\to \;\D{Expr}\;\to \;\D{Expr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Using this data type,\footnote{Agda supports the definition of mixfix operators.
We can use underscores to mark arguments positions.} we can construct expressions
that denote terms that should not be considered well-typed like
\ensuremath{(\Con{Num}\;\V{1})\;\F{+}\;\Con{True}}. Using this approach, we need to specify the static semantics
as another definition, which should consider all possible cases to avoid the
definition of ill-typed terms.

A better approach is to combine the static semantics and language syntax into
a single definition, as shown below.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Nat}\;\Con{Bool}\;\mathbin{:}\;\D{Ty}{}\<[E]%
\\[\blanklineskip]%
\>[4]{}\mathkw{data}\;\D{Expr}\;\mathbin{:}\;\D{Ty}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{True}\;\Con{False}\;\mathbin{:}\;\D{Expr}\;\Con{Bool}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Num}\;\mathbin{:}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_\land\_}\;\mathbin{:}\;\D{Expr}\;\Con{Bool}\;\to \;\D{Expr}\;\Con{Bool}\;\to \;\D{Expr}\;\Con{Bool}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_+\_}\;\mathbin{:}\;\D{Expr}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In this definition, the \ensuremath{\D{Expr}} type is indexed by a value of type \ensuremath{\D{Ty}} which
indicates the type of the expression being built. In this approach, Agda's
type system can enforce that only well-typed terms could be written.
%A definition which uses the expression |(Num 1) + True| will be rejected by Agda's type checker automatically.
Agda's type checker will automatically reject a definition which uses the expression \ensuremath{(\Con{Num}\;\V{1})\;\F{+}\;\Con{True}}.

%Dependently typed pattern matching is built by using the so-called
%|with| construct, that allows for matching intermediate
%values~\cite{McBride2004}. If the matched value has a dependent type,
%then its result can affect the form of other values. For example,
%consider the following code that defines a type for natural number
%parity. If the natural number is even, it can be represented as the
%sum of two equal natural numbers; if it is odd, it is equal to one
%plus the sum of two equal values. Pattern matching on a value of
%|Parity n| allows to discover if $n = j + j$ or $n = S (k + k)$,
%for some $j$ and $k$ in each branch of |with|.  Note that the
%value of $n$ is specialized accordingly, using information ``learned''
%by the type-checker.
%\begin{spec}
%data Parity : Nat -> Set where
%   Even : forall {n : Nat} -> Parity (n + n)
%   Odd  : forall {n : Nat} -> Parity (S (n + n))
%
%parity : (n : Nat) -> Parity n
%parity = -- definition omitted

%natToBin : Nat -> List Bool
%natToBin zero = []
%natToBin k with (parity k)
%   natToBin (j + j)     | Even = false :: natToBin j
%   natToBin (succ (j + j)) | Odd  = true  :: natToBin j
%\end{spec}

For further information about Agda, see~\cite{Norell2009,Stump16}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% List machine benchmark %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{The List Machine Benchmark}\label{sec:list}

The list machine is a simple pointer virtual machine whose values
are empty lists and cons-cells:
\[
a ::= nil\,\mid\,cons(a_1,a_2)
\]
We let meta-variable $a$ to denote an arbitrary value, $v$ denotes a variable
and $l$ a program label. Following common practice, all meta-variables can
appear primed or subscripted. The syntax of the virtual machine instructions are
presented next and their meaning is as usual.
\[
\begin{array}{rcll}
  i & ::=  & \text{jump }l                       & \text{(jump instruction)}\\
    & \mid & \text{branch-if-nil $v$}            & \text{(if $v = nil$ goto $l$)}\\
    & \mid & \text{fetch-field $v$ 0 $v'$}       & \text{(fetch the head of $v$ into $v'$)}\\
    & \mid & \text{fetch-field  $v$ 1 $v'$}      & \text{(fetch the tail of $v$ into $v'$)}\\
    & \mid & \text{cons $v_0$ $v_1$ $v'$}        & \text{(make a cons cell in v')} \\
    & \mid & \text{halt}                         & \text{(finishes execution)}\\
    & \mid & i_1;i_2                             & \text{(sequential composition)}\\
  p & ::=  & l_i \,:\,i\,;\,p                    & \text{(program: sequence of blocks)}\\
    & \mid & \text{end}                          & \text{(end of block list)}\\
\end{array}
\]
Programs are just a sequence of blocks which begin with a unique label. 

Each program variable is assigned a list type which is used to guarantee the safety of execute
fetch-field that demands non-empty list arguments and branch instructions refine the argument type
according to which branch is taken. In order to express such refinements, types are subject to a
subtyping relation. We let the meta-variable $\tau$ denote an arbitrary type. 
\[
\begin{array}{rcll}
  \tau & ::=  & \text{nil} & \text{(type for empty lists)}\\
       & \mid & \text{list }\tau & \text{(lists whose elements have type $\tau$)}\\
       & \mid & \text{listcons }\tau & \text{(non-empty lists of $\tau$)}\\
\end{array}
\]
We let notation $\tau \subset \tau'$
denote the subtyping judgement which is defined as follows.
\[
\begin{array}{ccc}
  \inference{}
            {\tau\subset \tau}
            [refl]
  &
  \inference{}
            {nil \subset \tau}
            [nil]
  &
  \inference{\tau \subset \tau'}
            {list\:\tau\subset list\:\tau'}
            [list]\\\\
  \multicolumn{3}{c}{
  \inference{\tau \subset \tau'}
            {listcons\:\tau\subset list\:\tau'}
            [listcons]} \\\\
            \multicolumn{3}{c}{
            \inference{\tau \subset \tau'}
            {listcons\:\tau\subset listcons\:\tau'}
            [mixed]} \\\\
\end{array}
\]
Basically, the subtyping relation specifies that $nil$ (empty list type) is
subtype of any list type and $listcons\:\tau$ is a subtype of the $list\:\tau$.
The other rules specifies that type constructors $list$ and $listcons$ respect
the subtyping relation.

Using the previously defined type syntax and its subtyping relation, we can
define the typing rules for the list machine. Following common practice, we
let meta-variable $\Gamma$ denote an environment between variable names and
its type. Notation $\{\}$ denote an empty environment and $v : \tau , \Gamma'$
denote the operation of including a new entry for variable $v$ with type $\tau$.
Subtyping is extended to contexts as follows.
\[
\begin{array}{cc}
  \inference{}
            {\Gamma \subset_{env} \{\}}[b1]
  &
  \inference{\tau' \subset \tau & \Gamma' \subset_{env} \Gamma_2}
            {v : \tau' , \Gamma' \subset_{env} v : \tau , \Gamma_2}
            [b2]
\end{array}
\]
Variable $\Pi$ denote \emph{program typings}, i.e. finite mappings between labels and typing contexts $\Gamma$,
where notation $\Pi(l) = \Gamma$ denotes that $\Gamma$ stores the types of variables on the entry point of the block
labeled by $l$. 


\begin{equation}
\inference{}
          {(r, (\iota_1;\iota_2);\iota_3) \xmapsto{p} (r, \iota_1;(\iota_2;\iota_3))}[step-seq]
\end{equation}

\begin{equation}
\inference{r(v) = cons(a_0,a_1)~~~r[v':=a_0]=r'}
          {(r, (\textbf{fetch-field}~v~0~v';\iota)) \xmapsto{p} (r', \iota)}[step-fetch-field-0]
\end{equation}

\begin{equation}
\inference{r(v) = cons(a_0,a_1)~~~r[v':=a_1]=r'}
          {(r, (\textbf{fetch-field}~v~1~v';\iota)) \xmapsto{p} (r', \iota)}[step-fetch-field-1]
\end{equation}

\begin{equation}
\inference{r(v_0) = a_0~~~r(v_1)=a_1~~~r[v':=cons(a_0,a_1)]=r'}
          {(r, (\textbf{cons}~v_0~v_1~v';\iota)) \xmapsto{p} (r', \iota)}[step-cons]
\end{equation}

\begin{equation}
\inference{r(v) = cons(a_0,a_1)}
          {(r, (\textbf{branch-if-nil}~v~l;\iota)) \xmapsto{p} (r, \iota)}[step-branch-not-taken]
\end{equation}

\begin{equation}
\inference{r(v) = nil~~~p(l)=\iota'}
          {(r, (\textbf{branch-if-nil}~v~l;\iota)) \xmapsto{p} (r, \iota')}[step-branch-taken]
\end{equation}

\begin{equation}
\inference{p(l)=\iota'}
          {(r, \textbf{jump}~l) \xmapsto{p} (r, \iota')}[step-jump]
\end{equation}

\begin{equation}
\inference{(r, \iota) \xmapsto{p} (r', \iota')~~~(p, r', \iota')}
          {(p, r, \iota) \Downarrow}[run-step]
\end{equation}

\begin{equation}
\inference{}
          {(p, r, \textbf{halt}) \Downarrow}[run-halt]
\end{equation}

\begin{equation}
\inference{\{\}[\textbf{v}_0:=\text{nil}]=r~~~p(\textbf{L}_0)=\iota~~~(p,r,\iota)\Downarrow}
          {p \Downarrow}[run-prog]
\end{equation}


%\subsubsection{Instruction typing}

\begin{equation}
\inference{\Pi \vdash_{\text{instr}} \Gamma\{ \iota_1 \}\Gamma'~~~\Pi \vdash_{\text{instr}} \Gamma'\{ \iota_2 \}\Gamma''}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \iota_1 ; \iota_2 \}\Gamma''}[check-instr-seq]
\end{equation}

\begin{equation}
\inference{\Gamma(v) = \text{list}~\tau~~~\Pi(l) = \Gamma_1~~~\Gamma[v:=\text{nil}]=\Gamma'~~~\Gamma' \subset \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}(v: \text{listcons}~\tau,~\Gamma')}[check-instr-branch-list]
\end{equation}

\begin{equation}
\inference{\Gamma(v) = \text{listcons}~\tau~~~\Pi(l) = \Gamma_1~~~\Gamma[v:=\text{nil}]=\Gamma'~~~\Gamma' \subset \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}\Gamma}[check-instr-branch-listcons]
\end{equation}

\begin{equation}
\inference{\Gamma(v) = \text{nil}~~~\Pi(l) = \Gamma_1~~~\Gamma \subset \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}\Gamma}[check-instr-branch-nil]
\end{equation}

\begin{equation}
\inference{\Gamma(v) = \text{listcons}~\tau~~~\Gamma[v':=\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{fetch-field}~v~0~v' \}\Gamma'}[check-instr-fetch-0]
\end{equation}

\begin{equation}
\inference{\Gamma(v) = \text{listcons}~\tau~~~\Gamma[v':=\text{list}~\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{fetch-field}~v~1~v' \}\Gamma'}[check-instr-fetch-1]
\end{equation}

\begin{equation}
\inference{\Gamma(v_0) = \tau_0~~~~~~~~~\Gamma(v_1) = \tau_1 \\ (\text{list}~\tau_0) \sqcap \tau_1=\text{list}~\tau~~~\Gamma[v:=\text{listcons}~\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{cons}~v_0~v_1~v \}\Gamma'}[check-instr-cons]
\end{equation}

%\subsubsection{Block typings}

\begin{equation}
\inference{}
          {\Pi;\Gamma\vdash_{\text{block}} \textbf{halt}}[check-block-halt]
\end{equation}

\begin{equation}
\inference{\Pi\vdash_{\text{instr}} \Gamma\{\iota_1\}\Gamma'~~~\Pi;\Gamma'\vdash_{\text{block}} \iota_2}
          {\Pi;\Gamma\vdash_{\text{block}} \iota_1;\iota_2}[check-block-seq]
\end{equation}

\begin{equation}
\inference{\Pi(l)=\Gamma_1~~~\Gamma \subset \Gamma_1}
          {\Pi;\Gamma\vdash_{\text{block}} \textbf{jump}~l}[check-block-jump]
\end{equation}

%\subsubsection{Program typings}

\begin{equation}
\inference{\Pi(l)=\Gamma~~~\Pi;\Gamma\vdash_{\text{block}} \iota~~~\Pi\vdash_{\text{blocks}} p}
          {\Pi\vdash_{\text{blocks}} l: \iota;~p}[check-blocks-label]
\end{equation}

\begin{equation}
\inference{}
          {\Pi\vdash_{\text{blocks}} \textbf{end}}[check-blocks-empty]
\end{equation}

\section{Instrinsically-typed syntax}\label{sec:typing}


In this section we present the design choices and the steps we took to represent the intrinsically-typed syntax for the list-machine benchmark. We present here the Agda code used in our definitions, not necessarily in a strict lexically-scoped order.

Some definitions and rules have been slightly tweaked so that they are accepted by the Agda's type-checker. As a design choice, we dropped all names, using \emph{de Bruijn} indices~\cite{DEBRUIJN72} to represent both \emph{name bindings} for labels and variables. This way, we guarantee that names are always well-scoped.

We started our formalization by defining a type \ensuremath{\D{Ty}}, indicating the possible types for the list-machine language.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{list}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{listcons}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We internalize the list-machine type judgments for blocks and instructions in Agda together with its syntax in such a way where only well-typed terms that satisfy typing judgments have meaning. This approach makes the AST contain both syntactic and semantic properties.

To be well-typed, the list-machine syntax needs to refer to information from two sources: (1) a type context encoded as a list of types to store variable types; and (2) and a program context encoded as a vector\footnote{We use the \ensuremath{\D{Vec}} datatype indexed by a \ensuremath{\V{n}} which is bound on the module definition and represents the number of labels in the current program.} of type contexts to represent the types of the variables on entry to each basic block.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Ctx}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Ctx}\;\mathrel{=}\;\D{List}\;\D{Ty}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\D{PCtx}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{PCtx}\;\mathrel{=}\;\D{Vec}\;\D{Ctx}\;\V{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


As we saw in the previous section, the typing rules of the list-machine language were split in two segments, one for instructions and one for blocks. We defined two datatypes (\ensuremath{\D{\_\vdash\_\Rightarrow\_}} and \ensuremath{\D{Block}}) to hold the well-typed terms accordingly, representing each judgment of the static semantics as a syntactical constructor. In Agda we use \emph{indexed inductive types} to define a intrinsically-typed syntax.

Both definitions are \emph{parameterized} by a program context and a typing context, and \emph{indexed}\footnote{An index can vary in the result types of the different constructors, while a parameter cannot.} by a resulting typing context. The intuition is that, under program-typing \ensuremath{\V{\Pi}}, the \emph{Hoare triple} \ensuremath{\V{\Gamma}\;\{\mskip1.5mu \V{\iota}\mskip1.5mu\}\;\V{\Gamma'}} relates precondition \ensuremath{\V{\Gamma}} to postcondition \ensuremath{\V{\Gamma'}}. It is important to note that instead of manipulating syntax directly, the meta-program manipulates structures representing the type judgments as well. Such representation scheme makes the Agda's type-checker allow only well-typed blocks and instructions to be created and manipulated.

The representation of instructions is defined as follows.




\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{\_\vdash\_\Rightarrow\_}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}seq}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\;\V{\Gamma''}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma'}\;\D{\Rightarrow}\;\V{\Gamma''}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma''}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}list}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{l}\;\V{\Gamma'}\;\V{x}\mskip1.5mu\}\;\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x}\;\red{,}\,\;\Con{list}\;\V{\tau})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma'}\;\rightarrow\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{nil}))\;\D{\subset}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}listcons}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{l}\;\V{\Gamma_1}\;\V{x}\mskip1.5mu\}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;\rightarrow\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{nil}))\;\D{\subset}\;\V{\Gamma_1}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}nil}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma_1}\;\V{l}\;\V{x}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{nil})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;\rightarrow\;\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau'}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\Con{list}\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau'}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\Con{list}\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}cons\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau_0}\;\V{\tau_1}\;\V{x₀}\;\V{x₁}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}\;\rightarrow\;\Con{list}\;\V{\tau_0}\;\D{\sqcap}\;\V{\tau_1}\;\D{\sim}\;\Con{list}\;\V{\tau}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}cons\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau_0}\;\V{\tau_1}\;\V{\tau_2}\;\V{x₀}\;\V{x₁}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}\;\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau_2})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\Con{list}\;\V{\tau_0}\;\D{\sqcap}\;\V{\tau_1}\;\D{\sim}\;\Con{list}\;\V{\tau}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\Con{listcons}\;\V{\tau})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


In our approach, all name binding is done with statically checked \emph{de Bruijn} indices~\cite{DEBRUIJN72}, a technique for handling binding by using a nameless, position-dependent naming scheme. For example, we use a well-typed \emph{de Bruijn} index \ensuremath{(\V{x}\;\red{,}\,\;\V{\tau})\;\D{\in}\;\V{\Gamma}}, which witnesses the existence of an element \ensuremath{(\V{x}\;\red{,}\,\;\V{\tau})} in \ensuremath{\V{\Gamma}}, as defined by the standard library \ensuremath{\D{\_\hspace{-2pt}\in\hspace{-2pt}\_}} operator. This technique is well-known for avoiding out-of-bound errors.

\paragraph{Sequencing instructions}{The constructor \ensuremath{\Con{instr\textrm{-}seq}} can be used to express a sequence of instructions. From the execution of two instructions, it produces a modified typing context containing the changes performed by both instructions.}

\paragraph{Conditional jump}{There are three constructors related to a conditional jump. They are used to perform a jump to a label \ensuremath{\V{l}} when the received variable is \ensuremath{\Con{nil}}. All these constructors type-check the typing context of the intended label with the current typing context. We use \ensuremath{\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}}, meaning that there exist a typing context \ensuremath{\V{\Gamma_1}} in program typing \ensuremath{\V{\Pi}} related to label \ensuremath{\V{l}}. And we use \ensuremath{\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}} as a proof of subtyping between \ensuremath{\V{\Gamma}} and \ensuremath{\V{\Gamma_1}}.}

\paragraph{Fetching information from list}{There are four constructors which can be used to fetch information from a given list. The constructor \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}} receives a non-empty list (\ensuremath{\Con{listcons}}), and is used to retrieve the head of this list and store it in a fresh new variable. The resulting typing context adds the information about the new variable. Constructor \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}} is also used to retrieve the head element of a list, however storing its value in an existing variable, represented by the \emph{de Bruijn} index \ensuremath{\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma}}. The constructors \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}} and \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}} are similar, fetching the tail of a list instead of the head.}


\paragraph{List construction}{The \ensuremath{\Con{instr\textrm{-}cons\textrm{-}new}} and \ensuremath{\Con{instr\textrm{-}cons\textrm{-}upd}} constructors are used to create a new list. The first creates a new variable, and the second updates a existing variable. The list is created from two variables, \ensuremath{(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}} and \ensuremath{(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}}, which are represented as \emph{de Bruijn} indices. The type of the new list is defined by the least common supertype\footnote{A complete explanation about the least common supertype can be found in the original list-machine paper~\cite{Appel07}.}, which is defined by the constructor \ensuremath{\D{\_\sqcap\_\sim\_}}\footnote{The code of this definition is omitted here, but can be found in our online repository.}. The resulting typing context adds information about the newly created list.}


The representation of blocks is defined as follows.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Block}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;{}\<[42]%
\>[42]{}\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}halt}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}seq}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\;\V{\Gamma''}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[15]{}\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma'}\;\V{\Gamma''}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma''}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}jump}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{l}\;\V{\Gamma_1}\;\V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;{}\<[E]%
\\
\>[15]{}\rightarrow\;\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Constructor \ensuremath{\Con{block\textrm{-}halt}} can be used to stop the execution of a given block, \ensuremath{\Con{block\textrm{-}seq}} has a similar meaning to instruction sequence, and \ensuremath{\Con{block\textrm{-}jump}} is used to perform a direct jump (without any condition), receiving a label and checking if the current context typing is subtype of the intended one.


And finally, a \ensuremath{\D{Program}} is a sequence of instruction blocks, each preceded by a label. We use the \ensuremath{\D{All}} datatype to express this relationship.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Program}\;\mathbin{:}\;\D{PCtx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Program}\;\V{\Pi}\;\mathrel{=}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\D{All}\;(\lambda\;\V{\Gamma}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'})\;\V{\Pi}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{A definitional interpreter}\label{sec:semantics}


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Val}\;\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;\mathbin{:}\;\D{Val}\;\Con{nil}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{[]v}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;\V{t}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t})\;\rightarrow\;\D{Val}\;(\Con{listcons}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{\_::v\_}\;\mathbin{:}\;{}\<[11]%
\>[11]{}\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;\V{t}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t})\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Env}\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Env}\;\V{\Gamma}\;\mathrel{=}\;\D{All}\;(\lambda\;(\V{x}\;\red{,}\,\;\V{\tau})\;\rightarrow\;\D{Val}\;\V{\tau})\;\V{\Gamma}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{PEnv}\;\mathbin{:}\;\D{PCtx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{PEnv}\;\V{\Pi}\;\mathrel{=}\;\D{Allv}\;\D{Env}\;\V{\Pi}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks





\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\D{Fuel}\;\rightarrow\;\D{Program}\;\V{\Pi}\;\rightarrow\;\D{Env}\;\V{\Gamma}\;{}\<[E]%
\\
\>[11]{}\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}\;\rightarrow\;\D{Maybe}\;(\D{Env}\;\V{\Gamma'}){}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;\Con{zero}\;\V{p}\;\V{env}\;\V{b}\;\mathrel{=}\;\Con{nothing}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;\Con{block\textrm{-}halt}\;\mathrel{=}\;\Con{just}\;\V{env}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}seq}\;\V{i₁}\;\V{i₂})\;\V{b})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\F{run\textrm{-}step}\;\V{n}\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;\V{i₁}\;(\Con{block\textrm{-}seq}\;\V{i₂}\;\V{b})){}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;\{\mskip1.5mu \V{\Pi}\mskip1.5mu\}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}branch\textrm{-}list}\;\{\mskip1.5mu \V{\tau}\mskip1.5mu\}\;\{\mskip1.5mu \V{i}\mskip1.5mu\}\;\V{v}\;\V{l}\;\V{s})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{[]v}\;\mathkw{rewrite}\;\D{sym}\;(\F{[]\textrm{=}{\Rightarrow}lookup}\;\V{l})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{\subset\hspace{-3pt}\textrm{-}Ctx}\;\V{s}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v}\;\Con{nil}))\;(\F{lookupA}\;\V{i}\;\V{p}){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\V{v₁}\;\Con{::\hspace{-2pt}v}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v}\;(\V{v₁}\;\Con{::}\;\V{v₂}))\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}branch\textrm{-}listcons}\;\V{v}\;\V{l}\;\V{s})\;\V{b})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\F{run\textrm{-}step}\;\V{n}\;\V{p}\;\V{env}\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}branch\textrm{-}nil}\;\{\mskip1.5mu \V{l}\;\mathrel{=}\;\V{i}\mskip1.5mu\}\;\V{v}\;\V{l}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{rewrite}\;\D{sym}\;(\F{[]\textrm{=}{\Rightarrow}lookup}\;\V{l})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{\subset\hspace{-3pt}\textrm{-}Ctx}\;\V{s}\;\V{env})\;(\F{lookupA}\;\V{i}\;\V{p}){}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;\V{v})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\V{v₁}\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;\V{v}\;\V{v'})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v'}\;\V{v₁})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}\;\V{v})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\V{v₂}\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}\;\V{v}\;\V{v'})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v'}\;\V{v₂})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}cons\textrm{-}new}\;\V{v₀}\;\V{v₁}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;((\F{\textrm{<:-}val}\;(\F{list\textrm{-<:-}inv}\;(\F{lub\textrm{-}subtype\textrm{-}left}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\F{lub\textrm{-}of\textrm{-}subtype}\;(\F{lub\textrm{-}subtype\textrm{-}left}\;\V{s}))))\;(\F{lookup}\;\V{env}\;\V{v₀}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{::}\;\F{\textrm{<:-}val}\;(\F{lub\textrm{-}subtype\textrm{-}right}\;\V{s})\;(\F{lookup}\;\V{env}\;\V{v₁}))\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}cons\textrm{-}upd}\;\V{v₀}\;\V{v₁}\;\V{v'}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v'}\;(\F{\textrm{<:-}val}\;(\F{list\textrm{-<:-}inv}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\F{lub\textrm{-}subtype\textrm{-}left}\;(\F{lub\textrm{-}of\textrm{-}subtype}\;(\F{lub\textrm{-}subtype\textrm{-}left}\;\V{s})))){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\F{lookup}\;\V{env}\;\V{v₀})\;\Con{::}\;\F{\textrm{<:-}val}\;(\F{lub\textrm{-}subtype\textrm{-}right}\;\V{s}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\F{lookup}\;\V{env}\;\V{v₁})))\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}jump}\;\{\mskip1.5mu \V{l}\;\mathrel{=}\;\V{i}\mskip1.5mu\}\;\V{l}\;\V{s})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{rewrite}\;\D{sym}\;(\F{[]\textrm{=}{\Rightarrow}lookup}\;\V{l})\;\mathrel{=}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{\subset\hspace{-3pt}\textrm{-}Ctx}\;\V{s}\;\V{env})\;(\F{lookupA}\;\V{i}\;\V{p}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Related work}\label{sec:related}

\section{Conclusion}\label{sec:conclusion}



\bibliographystyle{ACM-Reference-Format}
\bibliography{main}
\end{document}
\endinput
