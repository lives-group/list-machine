\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{graphicx}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{ifpdf}
\usepackage{mathtools}
\usepackage{semantic}

\ifpdf
\usepackage{hyperref}
\fi
\usepackage{float}
\usepackage{proof}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}


\acmConference[SBLP '20]{SBLP '20: Brazilian Symposium on Programming Languages}{October 19--23, 2020}{Natal, Brazil}
\acmBooktitle{SBLP '20: Brazilian Symposium on Programming Languages,
  October 19--23, 2020, Natal, Brazil}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% color formatting stuff %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{Example}{Example}

\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff



%%%%%%%%%%%%%%%%%%%%
%% lhs2TeX stuff  %%
%%%%%%%%%%%%%%%%%%%%


%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\Con}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%
%% Title and authors %%
%%%%%%%%%%%%%%%%%%%%%%%



\title{A Certified Interpreter for the List Machine Benchmark}

\author{Samuel Feitosa}
\authornotemark[1]
\email{samuel.feitosa@ifsc.edu.br}
\affiliation{%
  \institution{Departamento de Informática}
  \streetaddress{Instituto Federal de Santa Catarina}
  \city{Caçador}
  \state{Santa Catarina}
  \country{Brazil}
}

\author{Rodrigo Ribeiro}
\email{rodrigo.ribeiro@ufop.edu.br}
\affiliation{%
  \institution{Prog. Pós Graduação em Ciência da Computação}
  \streetaddress{Universidade Federal de Ouro Preto}
  \city{Ouro Preto}
  \state{Minas Gerais}
  \country{Brazil}}


%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract          %%
%%%%%%%%%%%%%%%%%%%%%%%



\begin{abstract}
Formal models are important tools in the programming languages research
community. However, such models are full of intrincacies and, due to that,
they are subject to subtle errors. Such failures motivated the usage of
tools to ensure the correctness of these formalisms. One way to eliminate
such errors is to encode models in a dependently-typed language in order
to ensure its ``correctness-by-construction''.

In this work, we use this idea to build a verified interpreter
for the list machine benchmark in the Agda programming language.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%
%% ACM codes for areas %%
%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{CCSXML}\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\V{ccs2012>}{}\<[E]%
\\
\>[B]{}\V{concept>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 id>10011007.10011006.10011039.10011311</concept\char95 id>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 desc>Software}\;\V{and}\;\V{its}\;\V{engineering\char126 Semantics</concept\char95 desc>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 significance>500</concept\char95 significance>}{}\<[E]%
\\
\>[B]{}\V{/concept>}{}\<[E]%
\\
\>[B]{}\V{concept>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 id>10011007.10011006.10011041.10010943</concept\char95 id>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 desc>Software}\;\V{and}\;\V{its}\;\V{engineering\char126 Interpreters</concept\char95 desc>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 significance>500</concept\char95 significance>}{}\<[E]%
\\
\>[B]{}\V{/concept>}{}\<[E]%
\\
\>[B]{}\V{concept>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 id>10003752.10003790.10011740</concept\char95 id>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 desc>Theory}\;\V{of}\;\V{computation\char126 Type}\;\V{theory</concept\char95 desc>}{}\<[E]%
\\
\>[B]{}\V{concept\char95 significance>500</concept\char95 significance>}{}\<[E]%
\\
\>[B]{}\V{/concept>}{}\<[E]%
\\
\>[B]{}\V{/ccs2012>}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Semantics}
\ccsdesc[500]{Software and its engineering~Interpreters}
\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Dependent types, formal semantics}

\maketitle



%%%%%%%%%%%%%%%%%%%%%%%
%% Introduction      %%
%%%%%%%%%%%%%%%%%%%%%%%



\section{Introduction}

The development of a new programming language design, linguistic construct
or type system involves its careful formalization in order to express
its core ideas in a concise way. However, such models have many details
and complexities which can hinders its correctness assurances.
Because of such problems, the programming languages research community
started to use tools, like proof assistants~\cite{Stump16,Chlipala13},
and benchmark problems to validate them and stress its suitability for
such specification tasks~\cite{Aydemir05,Pientka18,Appel07}.

A popular approach for specifying formal semantics is the
use of definitional interpreters, which represents the meaning of a
programming language as an interpreter written in some
meta-language~\cite{Reynolds72}. A major advantage of such approach
is the possibility of validating the semantics through execution.
Recently, definitional interpreters were used to formalize type
soundness theorems for some advanced typing features~\cite{Amin17}
and the semantics of imperative programming languages in which static
semantics is ensured by dependently-typed
syntax\footnote{Also known as intrinsically-typed.}~\cite{Poulsen18}.
In this work, we follow Poulsen et. al and use an intrinsically-typed
representation to build a definitional interpreter for a low-level virtual
machine developed by Appel and Leroy as a benchmark problem closer to
real-world implementations like typed assembly languages~\cite{CraryM99} and
proof carrying code~\cite{Necula97}.

More specifically, we contribute:

\begin{itemize}
  \item We show how all the details of the list machine type system
        can be encoded as dependently-typed syntax which avoids, by construction,
        the presence of stuck states in its definitional interpreter.
  \item We provide a provably correct implementations for testing the subtyping
        relation and to calculate the least common super type of two input
        types for the machine registers.
  \item We provide a correct by construction implementation of a type checker for
        list machine programs. Our type checker produces, as result, an intrinsically-typed
        representation of the machine code.
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{sec:agda}
presents a brief introduction to Agda and Section~\ref{sec:list}
reviews the list machine benchmark and presents its syntax and type system.
We describe the intrinsically-typed representation for the list machine syntax,
the subtyping relation and the least common super type algorithm in
Section~\ref{sec:typing}. The list machine semantics and its realization as
a definitional interpreter are presented in Section~\ref{sec:semantics}.
Related work is discussed in Section~\ref{sec:related},
and Section~\ref{sec:conclusion} concludes.

All the source code in this article has been formalized in Agda
version 2.6.1 using Standard Library 1.3. All source code produced,
including the \LaTeX~source of this article, are available
on-line~\cite{list-rep}.


%%%%%%%%%%%%%%%%%%%%%%%
%% Overview of Agda  %%
%%%%%%%%%%%%%%%%%%%%%%%



\section{An Overview of Agda}\label{sec:agda}


Agda is a dependently-typed functional programming language based on
Martin-L\"of intuitionistic type theory~\cite{Lof98}.  Function types
and an infinite hierarchy of types of types, \ensuremath{\D{Set}\;\V{l}}, where \ensuremath{\V{l}} is a
natural number, are built-in. Everything else is a user-defined
type. The type \ensuremath{\D{Set}}, also known as \ensuremath{\D{Set}_{\D{0}}}, is the type of all
``small'' types, such as \ensuremath{\D{Bool}}, \ensuremath{\D{String}} and \ensuremath{\D{List}\;\D{Bool}}.  The type
\ensuremath{\D{Set}_{\D{1}}} is the type of \ensuremath{\D{Set}} and ``others like it'', such as \ensuremath{\D{Set}\;\to \;\D{Bool}}, \ensuremath{\D{String}\;\to \;\D{Set}}, and \ensuremath{\D{Set}\;\to \;\D{Set}}. We have that \ensuremath{\D{Set}\;\V{l}} is an
element of the type \ensuremath{\D{Set}\;(\V{l+1})}, for every $l \geq 0$. This
stratification of types is used to keep Agda consistent as a logical
theory~\cite{Sorensen2006}.

An ordinary (non-dependent) function type is written \ensuremath{\V{A}\;\to \;\V{B}} and a
dependent one is written \ensuremath{(\V{x}\;\mathbin{:}\;\V{A})\;\to \;\V{B}}, where type \ensuremath{\V{B}} depends on
\ensuremath{\V{x}}, or \ensuremath{\D{\forall}\;(\V{x}\;\mathbin{:}\;\V{A})\;\to \;\V{B}}. Agda allows the definition of \emph{implicit
parameters}, i.e.,  parameters whose values can be inferred from the
context, by surrounding them in curly braces: \ensuremath{\D{\forall}\;\{\mskip1.5mu \V{x}\;\mathbin{:}\;\V{A}\mskip1.5mu\}\;\to \;\V{B}}. To
avoid clutter, we'll omit implicit arguments from the source code
presentation. The reader can safely assume that every free variable in
a type is an implicit parameter.

As an example of Agda code, consider the following data type of
length-indexed lists, also known as vectors.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{\mathbb{N}}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{zero}\;\mathbin{:}\;\D{\mathbb{N}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{suc}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{\mathbb{N}}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathkw{data}\;\D{Vec}\;(\V{A}\;\mathbin{:}\;\D{Set})\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{\lbrack\:\rbrack}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\D{Vec}\;\V{A}\;\Con{zero}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\V{A}\;\to \;\D{Vec}\;\V{A}\;\V{n}\;\to \;\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Constructor \ensuremath{\Con{\lbrack\:\rbrack}} builds empty vectors. The cons-operator (\ensuremath{\Con{\_::\_}})
inserts a new element in front of a vector of $n$ elements (of type
\ensuremath{\D{Vec}\;\V{A}\;\V{n}}) and returns a value of type \ensuremath{\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})}. The
\ensuremath{\D{Vec}} datatype is an example of a dependent type, i.e., a type
that uses a value (that denotes its length). The usefulness of
dependent types can be illustrated with the definition of a safe list
head function: \ensuremath{\F{head}} can be defined to accept only non-empty
vectors, i.e.,~values of type \ensuremath{\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{head}\;\mathbin{:}\;\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})\;\to \;\V{A}{}\<[E]%
\\
\>[3]{}\F{head}\;(\V{x}\;\Con{::}\;\V{xs})\;\mathrel{=}\;\V{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In \ensuremath{\F{head}}'s definition, constructor \ensuremath{\Con{\lbrack\:\rbrack}} is not used. The
Agda type-checker can figure out, from \ensuremath{\F{head}}'s parameter type,
that argument \ensuremath{\Con{\lbrack\:\rbrack}} to \ensuremath{\F{head}} is not type-correct.



Another useful data type is the finite type,
\ensuremath{\D{Fin}}\footnote{Note that Agda supports the overloading of
data type constructor names. Constructor \ensuremath{\Con{zero}} can refer to
type \ensuremath{\D{\mathbb{N}}} or \ensuremath{\D{Fin}}, depending on the context where the name
is used.}, which is defined in Agda's standard library as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{Fin}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{zero}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;(\Con{suc}\;\V{n}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{suc}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{Fin}\;(\Con{suc}\;\V{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Type \ensuremath{\D{Fin}\;\V{n}} has exactly \ensuremath{\V{n}} inhabitants
(elements), i.e., it is isomorphic to the set $\{0,...,n - 1\}$.
An application of such type is to define a safe vector
lookup function, which avoids the access of invalid positions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{lookup}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{A}\;\V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{Vec}\;\V{A}\;\V{n}\;\to \;\V{A}{}\<[E]%
\\
\>[3]{}\F{lookup}\;\Con{zero}\;(\V{x}\;\Con{::}\;\anonymous )\;\mathrel{=}\;\V{x}{}\<[E]%
\\
\>[3]{}\F{lookup}\;(\Con{suc}\;\V{idx})\;(\anonymous \;\Con{::}\;\V{xs})\;\mathrel{=}\;\F{lookup}\;\V{idx}\;\V{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Thanks to the propositions-as-types principle,\footnote{It is also known as
  Curry-Howard ``isomorphism''~\cite{Sorensen2006}.} we can interpret
types as logical formulas and terms as proofs. An example is the
representation of equality as the following Agda type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{\_ \equiv \_}\;\{\mskip1.5mu \V{l}\mskip1.5mu\}\;\{\mskip1.5mu \V{A}\;\mathbin{:}\;\D{Set}\;\V{l}\mskip1.5mu\}\;(\V{x}\;\mathbin{:}\;\V{A})\;\mathbin{:}\;\V{A}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{refl}\;\mathbin{:}\;\V{x}\;\D{\equiv}\;\V{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This type is called propositional equality. It defines that there is
a unique evidence for equality, constructor \ensuremath{\Con{refl}} (for reflexivity),
that asserts that the only value equal to \ensuremath{\V{x}} is itself. Given a predicate \ensuremath{\V{P}\;\mathbin{:}\;\V{A}\;\to \;\D{Set}}
and a vector \ensuremath{\V{xs}}, the type \ensuremath{\D{All}\;\V{P}\;\V{xs}} is used to build proofs that \ensuremath{\V{P}} holds for all
elements in \ensuremath{\V{xs}} and it is defined as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{All}\;(\V{P}\;\mathbin{:}\;\V{A}\;\to \;\D{Set})\;\mathbin{:}\;\D{Vec}\;\V{A}\;\V{n}\;\to \;{}\<[41]%
\>[41]{}\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Con{\lbrack\:\rbrack}\;\mathbin{:}\;\D{All}\;\V{P}\;\Con{\lbrack\:\rbrack}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{x}\;\V{xs}\mskip1.5mu\}\;\to \;\V{P}\;\V{x}\;\to \;\D{All}\;\V{P}\;\V{xs}\;\to \;\D{All}\;\V{P}\;(\V{x}\;\Con{::}\;\V{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The first constructor specifies that \ensuremath{\D{All}\;\V{P}} holds for the empty vector and
constructor \ensuremath{\Con{\_::\_}} builds a proof of \ensuremath{\D{All}\;\V{P}\;(\V{x}\;\Con{::}\;\V{xs})} from proofs of
\ensuremath{\V{P}\;\V{x}} and \ensuremath{\D{All}\;\V{P}\;\V{xs}}. Since this type has the same structure of vectors,
some functions on \ensuremath{\D{Vec}} have similar definitions for type \ensuremath{\D{All}}. As an example
used in our formalization, consider the function \ensuremath{\F{lookup}}, which extracts a
proof of \ensuremath{\V{P}} for the element at position \ensuremath{\V{v}\;\mathbin{:}\;\D{Fin}\;\V{n}} in a \ensuremath{\D{Vec}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\F{lookup}\;\mathbin{:}\;\{\mskip1.5mu \V{xs}\;\mathbin{:}\;\D{Vec}\;\V{A}\;\V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{All}\;\V{P}\;\V{xs}\;\to \;\V{P}\;\V{x}{}\<[E]%
\\
\>[4]{}\F{lookup}\;\Con{zero}\;(\V{px}\;\Con{::}\;\anonymous )\;\mathrel{=}\;\V{px}{}\<[E]%
\\
\>[4]{}\F{lookup}\;(\Con{suc}\;\V{idx})\;(\anonymous \;\Con{::}\;\V{pxs})\;\mathrel{=}\;\F{lookup}\;\V{idx}\;\V{pxs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
An important application of dependent types is to encode programming languages
syntax. The role of dependent types in this domain is to encode programs that
only allow well-typed and well-scoped terms~\cite{Benton2012}. Intuitively, we encode
the static semantics of the object language in the host language AST's
constructor, leaving the responsibility of checking type safety to the
host's language type checker. As an example, consider the following simple
expression language.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{Expr}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{True}\;\Con{False}\;\mathbin{:}\;\D{Expr}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Num}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Expr}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_\land\_}\;\Con{\_+\_}\;\mathbin{:}\;\D{Expr}\;\to \;\D{Expr}\;\to \;\D{Expr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Using this data type,\footnote{Agda supports the definition of mixfix operators.
We can use underscores to mark arguments positions.} we can construct expressions
that denote terms that should not be considered well-typed like
\ensuremath{(\Con{Num}\;\V{1})\;\F{+}\;\Con{True}}. Using this approach, we need to specify the static semantics
as another definition, which should consider all possible cases to avoid the
definition of ill-typed terms.

A better approach is to combine the static semantics and language syntax into
a single definition, as shown below.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Nat}\;\Con{Bool}\;\mathbin{:}\;\D{Ty}{}\<[E]%
\\[\blanklineskip]%
\>[4]{}\mathkw{data}\;\D{Expr}\;\mathbin{:}\;\D{Ty}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{True}\;\Con{False}\;\mathbin{:}\;\D{Expr}\;\Con{Bool}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Num}\;\mathbin{:}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_\land\_}\;\mathbin{:}\;\D{Expr}\;\Con{Bool}\;\to \;\D{Expr}\;\Con{Bool}\;\to \;\D{Expr}\;\Con{Bool}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_+\_}\;\mathbin{:}\;\D{Expr}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In this definition, the \ensuremath{\D{Expr}} type is indexed by a value of type \ensuremath{\D{Ty}} which
indicates the type of the expression being built. In this approach, Agda's
type system can enforce that only well-typed terms could be written.
%A definition which uses the expression |(Num 1) + True| will be rejected by Agda's type checker automatically.
Agda's type checker will automatically reject a definition which uses the expression \ensuremath{(\Con{Num}\;\V{1})\;\F{+}\;\Con{True}}.

%Dependently typed pattern matching is built by using the so-called
%|with| construct, that allows for matching intermediate
%values~\cite{McBride2004}. If the matched value has a dependent type,
%then its result can affect the form of other values. For example,
%consider the following code that defines a type for natural number
%parity. If the natural number is even, it can be represented as the
%sum of two equal natural numbers; if it is odd, it is equal to one
%plus the sum of two equal values. Pattern matching on a value of
%|Parity n| allows to discover if $n = j + j$ or $n = S (k + k)$,
%for some $j$ and $k$ in each branch of |with|.  Note that the
%value of $n$ is specialized accordingly, using information ``learned''
%by the type-checker.
%\begin{spec}
%data Parity : Nat -> Set where
%   Even : forall {n : Nat} -> Parity (n + n)
%   Odd  : forall {n : Nat} -> Parity (S (n + n))
%
%parity : (n : Nat) -> Parity n
%parity = -- definition omitted

%natToBin : Nat -> List Bool
%natToBin zero = []
%natToBin k with (parity k)
%   natToBin (j + j)     | Even = false :: natToBin j
%   natToBin (succ (j + j)) | Odd  = true  :: natToBin j
%\end{spec}

For further information about Agda, see~\cite{Norell2009,Stump16}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% List machine benchmark %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{The List Machine Benchmark}\label{sec:list}

The list machine is a simple pointer virtual machine whose values
are empty lists and cons-cells:
\[
a ::= nil\,\mid\,cons(a_1,a_2)
\]
We let meta-variable $a$ to denote an arbitrary value, $v$ denotes a variable
and $l$ a program label. Following common practice, all meta-variables can
appear primed or subscripted. The syntax of the virtual machine instructions are
presented next and their meaning is as usual.
\[
\begin{array}{rcll}
  \iota & ::=  & \text{jump }l                       & \text{(jump instruction)}\\
        & \mid & \text{branch-if-nil $v$}            & \text{(if $v = nil$ goto $l$)}\\
        & \mid & \text{fetch-field $v$ 0 $v'$}       & \text{(fetch the head of $v$ into $v'$)}\\
        & \mid & \text{fetch-field  $v$ 1 $v'$}      & \text{(fetch the tail of $v$ into $v'$)}\\
        & \mid & \text{cons $v_0$ $v_1$ $v'$}        & \text{(make a cons cell in v')} \\
        & \mid & \text{halt}                         & \text{(finishes execution)}\\
        & \mid & \iota_1;\iota_2                             & \text{(sequential composition)}\\
      p & ::=  & l_i \,:\,\iota\,;\,p                    & \text{(program: sequence of blocks)}\\
        & \mid & \text{end}                          & \text{(end of block list)}\\
\end{array}
\]
Programs are just a sequence of blocks which begin with a unique label. 

Each program variable is assigned a list type which is used to guarantee the safety of execute
fetch-field that demands non-empty list arguments and branch instructions refine the argument type
according to which branch is taken. In order to express such refinements, types are subject to a
subtyping relation. We let the meta-variable $\tau$ denote an arbitrary type. 
\[
\begin{array}{rcll}
  \tau & ::=  & \text{nil} & \text{(type for empty lists)}\\
       & \mid & \text{list }\tau & \text{(lists whose elements have type $\tau$)}\\
       & \mid & \text{listcons }\tau & \text{(non-empty lists of $\tau$)}\\
\end{array}
\]
We let notation $\tau \subset \tau'$
denote the subtyping judgement which is defined as follows.
\[
\begin{array}{ccc}
  \inference{}
            {\tau\subset \tau}
            [refl]
  &
  \inference{}
            {nil \subset \tau}
            [nil]
  &
  \inference{\tau \subset \tau'}
            {list\:\tau\subset list\:\tau'}
            [list]\\\\
  \multicolumn{3}{c}{
  \inference{\tau \subset \tau'}
            {listcons\:\tau\subset list\:\tau'}
            [listcons]} \\\\
            \multicolumn{3}{c}{
            \inference{\tau \subset \tau'}
            {listcons\:\tau\subset listcons\:\tau'}
            [mixed]} \\\\
\end{array}
\]
Basically, the subtyping relation specifies that $nil$ (empty list type) is
subtype of any list type and $listcons\:\tau$ is a subtype of the $list\:\tau$.
The other rules specifies that type constructors $list$ and $listcons$ respect
the subtyping relation. The list common supertype $\tau = \tau_1 \sqcap \tau_2$ of
$\tau_1$ and $\tau_2$ is defined as the smallest type such that $\tau_1$ and $\tau_2$
are subtypes of $\tau$.

Following common practice, we let meta-variable $\Gamma$ denote an
environment between variable names and
its types. Notation $\{\}$ denote an empty environment, $v : \tau , \Gamma$
denote the operation of including a new entry for variable $v$ with type $\tau$
in $\Gamma$ and $\Gamma [v := \tau]$ denotes the environment which is identical to $\Gamma$, except
by the entry which associates variable $v$ with type $\tau$.
Subtyping is extended to contexts as follows.
\[
\begin{array}{cc}
  \inference{}
            {\Gamma \subset_{env} \{\}}[b1]
  &
  \inference{\tau' \subset \tau & \Gamma' \subset_{env} \Gamma_2}
            {v : \tau' , \Gamma' \subset_{env} v : \tau , \Gamma_2}
            [b2]
\end{array}
\]
We let variable $\Pi$ denote \emph{program typings}, i.e. finite mappings between
labels and typing contexts $\Gamma$, where notation $\Pi(l) = \Gamma$ denotes that
$\Gamma$ stores the types of variables on the entry point of the block labeled by $l$.
Using the previously defined notations, we can define the typing rules for the list
machine as a syntax directed judgement $\Pi \vdash_{\text{instr}} \Gamma \{ \iota \} \Gamma'$
which intuitively means that the instruction $\iota$ transforms an input typing environment,
$\Gamma$, into an output environment $\Gamma'$ under a fixed program typing $\Pi$. The typing
rules for the list machine instructions are as follows.

The first typing rule we consider is the one for sequencing instructions inside a block. Basically,
the rule just threads the output environment from the first instruction as the input typing for the
second.
\[
\inference{\Pi \vdash_{\text{instr}} \Gamma\{ \iota_1 \}\Gamma'~~~\Pi \vdash_{\text{instr}} \Gamma'\{ \iota_2 \}\Gamma''}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \iota_1 ; \iota_2 \}\Gamma''}[seq]
\]
The type system proposed by Appel et. al.~\cite{Appel07} has three rules to deal with each of the possible
types assigned to the branch variable in current typing context. The first rules deal with the $list$ and $listcon$
types, which specifies that the environment associated to the label $l$, $\Pi(l) = \Gamma_1$, is greater than
$\Gamma[v := nil]$. The third rule applies whenever $\Gamma(v) = nil$ and it also demands that $\Gamma \subset \Pi(l)$.

\[
\begin{array}{c}
\inference{\Gamma(v) = \text{list}~\tau\:\:\:\:\:\:\:\:\Pi(l) = \Gamma_1\\
                     \Gamma[v:=\text{nil}]=\Gamma'\:\:\:\:\:\:\:\:\Gamma' \subset_{env} \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}(v: \text{listcons}~\tau,~\Gamma')}
          [branch-list]
\\ \\

\inference{\Gamma(v) = \text{listcons}~\tau\:\:\:\:\:\:\:\:\Pi(l) = \Gamma_1\\
           \Gamma[v:=\text{nil}]=\Gamma'\:\:\:\:\:\:\:\:\Gamma' \subset_{env} \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}\Gamma}[branch-listcons]

\\ \\
\inference{\Gamma(v) = \text{nil}~~~\Pi(l) = \Gamma_1~~~\Gamma \subset \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}\Gamma}
          [branch-nil]
\end{array}
\]
Next, we have the \emph{fetch} instruction which can be used to store the head / tail of a list value in
a variable. Rule \emph{fetch-0} retrieves the head of a value stored in a variable $v$ and \emph{fetch-1}
does the same for the tail. Note that both rules demand that $\Gamma(v) = listcons\:\tau$, for some type
$\tau$.
\[
\begin{array}{c}
\inference{\Gamma(v) = \text{listcons}~\tau~~~\Gamma[v':=\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{fetch-field}~v~0~v' \}\Gamma'}[fetch-0]
          \\ \\
\inference{\Gamma(v) = \text{listcons}~\tau~~~\Gamma[v':=\text{list}~\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{fetch-field}~v~1~v' \}\Gamma'}[fetch-1]
\end{array}
\]
The \emph{cons} instruction allows us to build a non-empty list value and this rule uses the least
common supertype operator to check if the result of the operation is really a list type.
\[
\inference{\Gamma(v_0) = \tau_0\:\:\:\:\:\:\:\:\Gamma(v_1) = \tau_1 \\
           (\text{list}~\tau_0) \sqcap \tau_1=\text{list}~\tau\:\:\:\:\:\:\:\:\Gamma[v:=\text{listcons}~\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{cons}~v_0~v_1~v \}\Gamma'}[cons]
\]
The final rules deal with the well-formedness of blocks and programs. The typing rules for \textbf{halt} instruction and
program \textbf{end} are completely trivial. Rule \emph{block-seq} does the typing context threading between sequential
instructions inside a block and rule \emph{block-label} recursively applies the judgment $\vdash_{block}$ on the
input program.

\[
\begin{array}{cc}
   \inference{}
             {\Pi;\Gamma\vdash_{\text{block}} \textbf{halt}}[halt]
   &

   \inference{\Pi\vdash_{\text{instr}} \Gamma\{\iota_1\}\Gamma'\\ \Pi;\Gamma'\vdash_{\text{block}} \iota_2}
             {\Pi;\Gamma\vdash_{\text{block}} \iota_1;\iota_2}[block-seq]\\ \\

   \inference{\Pi(l)=\Gamma_1\\ \Gamma \subset_{env} \Gamma_1}
             {\Pi;\Gamma\vdash_{\text{block}} \textbf{jump}~l}[jump]

   &
   \inference{}
             {\Pi\vdash_{\text{blocks}} \textbf{end}}[empty] \\ \\

   \multicolumn{2}{c}{
   \inference{\Pi(l)=\Gamma\:\:\:\:\:\:\:\:\Pi;\Gamma\vdash_{\text{block}} \iota\:\:\:\:\:\:\:\:\Pi\vdash_{\text{blocks}} p}
     {\Pi\vdash_{\text{blocks}} l: \iota;~p}[blocks-label]
    }
\end{array}
\]
Inspired by the typing rules designed by Appel et. al., in the next section, we define an intrisinsically
typed syntax for list machine programs which ensures that only well-typed programs can be built.

\section{Instrinsically-typed syntax}\label{sec:typing}


In this section we present the design choices and the steps we took to represent the
intrinsically-typed syntax for the list-machine benchmark. We present here the Agda
code used in our definitions, not necessarily in a strict lexically-scoped order.

Some definitions and rules have been slightly tweaked so that they are accepted by
the Agda's type-checker. As a design choice, we dropped all names, using
\emph{de Bruijn} indices~\cite{DEBRUIJN72} to represent both \emph{name bindings}
for labels and variables. This way, we guarantee that names are always well-scoped.

We started our formalization by defining a type \ensuremath{\D{Ty}}, indicating the possible types
for the list-machine language.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{list}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{listcons}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We internalize the list-machine type judgments for blocks and instructions in Agda
together with its syntax in such a way where only well-typed terms that satisfy typing
judgments have meaning. This approach makes the AST contain both syntactic and semantic
properties.

To be well-typed, the list-machine syntax needs to refer to information from two sources:
(1) a type context encoded as a list of types to store variable types; and (2) and a program
context encoded as a vector\footnote{We use the \ensuremath{\D{Vec}} datatype indexed by a \ensuremath{\V{n}} which is
bound on the module definition and represents the number of labels in the current program.}
of type contexts to represent the types of the variables on entry to each basic block.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Ctx}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Ctx}\;\mathrel{=}\;\D{List}\;\D{Ty}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\D{PCtx}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{PCtx}\;\mathrel{=}\;\D{Vec}\;\D{Ctx}\;\V{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


As we saw in the previous section, the typing rules of the list-machine language were split
in two segments, one for instructions and one for blocks. We defined two datatypes (\ensuremath{\D{\_\vdash\_\Rightarrow\_}} and \ensuremath{\D{Block}})
to hold the well-typed terms accordingly, representing each judgment of the static semantics as a
syntactical constructor. In Agda we use \emph{indexed inductive types} to define a intrinsically-typed syntax.

Both definitions are \emph{parameterized} by a program context and a typing context, and
\emph{indexed}\footnote{An index can vary in the result types of the different constructors,
while a parameter cannot.} by a resulting typing context. The intuition is that, under
program-typing \ensuremath{\V{\Pi}}, the \emph{Hoare triple} \ensuremath{\V{\Gamma}\;\{\mskip1.5mu \V{\iota}\mskip1.5mu\}\;\V{\Gamma'}} relates precondition \ensuremath{\V{\Gamma}} to
postcondition \ensuremath{\V{\Gamma'}}. It is important to note that instead of manipulating syntax directly,
the meta-program manipulates structures representing the type judgments as well. Such
representation scheme makes the Agda's type-checker allow only well-typed blocks and
instructions to be created and manipulated.

The representation of instructions is defined as follows.




\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{\_\vdash\_\Rightarrow\_}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}seq}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\;\V{\Gamma''}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma'}\;\D{\Rightarrow}\;\V{\Gamma''}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma''}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}list}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{l}\;\V{\Gamma'}\;\V{x}\mskip1.5mu\}\;\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x}\;\red{,}\,\;\Con{list}\;\V{\tau})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma'}\;\rightarrow\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{nil}))\;\D{\subset}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}listcons}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{l}\;\V{\Gamma_1}\;\V{x}\mskip1.5mu\}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;\rightarrow\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{nil}))\;\D{\subset}\;\V{\Gamma_1}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}nil}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma_1}\;\V{l}\;\V{x}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{nil})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;\rightarrow\;\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau'}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\Con{list}\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau'}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\Con{list}\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}cons\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau_0}\;\V{\tau_1}\;\V{x₀}\;\V{x₁}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}\;\rightarrow\;\Con{list}\;\V{\tau_0}\;\D{\sqcap}\;\V{\tau_1}\;\D{\sim}\;\Con{list}\;\V{\tau}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}cons\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau_0}\;\V{\tau_1}\;\V{\tau_2}\;\V{x₀}\;\V{x₁}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}\;\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau_2})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\Con{list}\;\V{\tau_0}\;\D{\sqcap}\;\V{\tau_1}\;\D{\sim}\;\Con{list}\;\V{\tau}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\Con{listcons}\;\V{\tau})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


In our approach, all name binding is done with statically checked \emph{de Bruijn}
indices~\cite{DEBRUIJN72}, a technique for handling binding by using a nameless,
position-dependent naming scheme. For example, we use a well-typed \emph{de Bruijn}
index \ensuremath{(\V{x}\;\red{,}\,\;\V{\tau})\;\D{\in}\;\V{\Gamma}}, which witnesses the existence of an element \ensuremath{(\V{x}\;\red{,}\,\;\V{\tau})} in \ensuremath{\V{\Gamma}},
as defined by the standard library \ensuremath{\D{\_\hspace{-2pt}\in\hspace{-2pt}\_}} operator. This technique is well-known for
avoiding out-of-bound errors.

\paragraph{Sequencing instructions}{The constructor \ensuremath{\Con{instr\textrm{-}seq}} can be used to
express a sequence of instructions. From the execution of two instructions, it
produces a modified typing context containing the changes performed by
both instructions.}

\paragraph{Conditional jump}{There are three constructors related to a conditional
jump. They are used to perform a jump to a label \ensuremath{\V{l}} when the received variable is \ensuremath{\Con{nil}}.
All these constructors type-check the typing context of the intended label with the
current typing context. We use \ensuremath{\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}}, meaning that there exist a typing context
\ensuremath{\V{\Gamma_1}} in program typing \ensuremath{\V{\Pi}} related to label \ensuremath{\V{l}}. And we use \ensuremath{\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}} as a proof of
subtyping between \ensuremath{\V{\Gamma}} and \ensuremath{\V{\Gamma_1}}. The operator \ensuremath{\F{\_\hspace{-2pt}::=\hspace{-2pt}\_}} is used to update the context \ensuremath{\V{\Gamma}}
in the position defined by the index \ensuremath{\V{idx}}.}

\paragraph{Fetching information from list}{There are four constructors which can be used
to fetch information from a given list. The constructor \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}} receives a
non-empty list (\ensuremath{\Con{listcons}}), and is used to retrieve the head of this list and store it
in a fresh new variable. The resulting typing context adds the information about the new
variable. Constructor \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}} is also used to retrieve the head element of a
list, however storing its value in an existing variable, represented by the \emph{de Bruijn}
index \ensuremath{\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma}}. The constructors \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}} and \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}}
are similar, fetching the tail of a list instead of the head.}


\paragraph{List construction}{The \ensuremath{\Con{instr\textrm{-}cons\textrm{-}new}} and \ensuremath{\Con{instr\textrm{-}cons\textrm{-}upd}} constructors are
used to create a new list. The first creates a new variable, and the second updates a
existing variable. The list is created from two variables, \ensuremath{(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}} and \ensuremath{(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}},
which are represented as \emph{de Bruijn} indices. The type of the new list is defined by
the least common supertype\footnote{A complete explanation about the least common supertype
can be found in the original list-machine paper~\cite{Appel07}.}, which is defined by the
constructor \ensuremath{\D{\_\sqcap\_\sim\_}}\footnote{The code of this definition is omitted here, but can be found
in our online repository.}. The resulting typing context adds information about the
newly created list.}


The representation of blocks is defined as follows.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Block}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;{}\<[42]%
\>[42]{}\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}halt}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}seq}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\;\V{\Gamma''}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[15]{}\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma'}\;\V{\Gamma''}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma''}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}jump}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{l}\;\V{\Gamma_1}\;\V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;{}\<[E]%
\\
\>[15]{}\rightarrow\;\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Constructor \ensuremath{\Con{block\textrm{-}halt}} can be used to stop the execution of a given block, \ensuremath{\Con{block\textrm{-}seq}} has a
similar meaning to instruction sequence, and \ensuremath{\Con{block\textrm{-}jump}} is used to perform a direct jump
(without any condition), receiving a label and checking if the current context typing is
subtype of the intended one.


And finally, a \ensuremath{\D{Program}} is a sequence of instruction blocks, each preceded by a label.
We use the \ensuremath{\D{All}} datatype to express this relationship.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Program}\;\mathbin{:}\;\D{PCtx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Program}\;\V{\Pi}\;\mathrel{=}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\D{All}\;(\lambda\;\V{\Gamma}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'})\;\V{\Pi}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{A definitional interpreter}\label{sec:semantics}

This section describes the steps to evaluate a program written using the list-machine language.
We adapted the small-step semantics presented in Section~\ref{sec:list}, transforming it in a
definitional interpreter~\cite{Reynolds72}, which evaluates an intrinsically-typed instruction,
transforming a initial memory state into a new one, represented by a run-time environment.


\paragraph{Values and environments}{The interpreter presented next needs to encode a run-time
environment to hold values associated to variables and their types. This way, we define the
notion of a well-typed value as follows.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Val}\;\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;\mathbin{:}\;\D{Val}\;\Con{nil}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{[]v}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;\V{t}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t})\;\rightarrow\;\D{Val}\;(\Con{listcons}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{\_::v\_}\;\mathbin{:}\;{}\<[11]%
\>[11]{}\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;\V{t}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t})\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The datatype \ensuremath{\D{Val}} is indexed by a \ensuremath{\D{Ty}}, indicating the type associated to each value. The
first two represent \ensuremath{\Con{nil}} values associated with type \ensuremath{\Con{nil}} and the empty \ensuremath{\Con{list}}. The last
two represent non-empty list, considering the types \ensuremath{\Con{listcons}} and \ensuremath{\Con{list}}.


We use the datatype \ensuremath{\D{All}} (and \ensuremath{\D{Allv}} for vectors) to define the notion of well-typed
variable environments and well-typed programs. Thus, intuitively, \ensuremath{\D{Env}} is like a
list of well-typed values. And \ensuremath{\D{PEnv}} is like a list of well-typed environments.
Both type environments are used to type block instructions and sequence of
block instructions.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Env}\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Env}\;\V{\Gamma}\;\mathrel{=}\;\D{All}\;(\lambda\;(\V{x}\;\red{,}\,\;\V{\tau})\;\rightarrow\;\D{Val}\;\V{\tau})\;\V{\Gamma}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{PEnv}\;\mathbin{:}\;\D{PCtx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{PEnv}\;\V{\Pi}\;\mathrel{=}\;\D{Allv}\;\D{Env}\;\V{\Pi}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks





\paragraph{Fuel based evaluation}{Having all the building blocks to make the
complete interpreter for the list-machine language, we can start the definition of
the \ensuremath{\F{run\textrm{-}step}} function. It is important to note that Agda is a total language,
i.e., each program developed in it must terminate and all possible patterns must
be matched. However, by using the mechanisms for jumping between labels one can
write a program which never ends, making it impossible to implement a terminating
interpreting function. Following the common practice, we define a fuel based
evaluator~\cite{Amin17,Owens2016}. Basically, what we do is to parameterize the
interpreter over a step index of \emph{fuel value} (represented as a natural
number $n$), which bounds the amount of work the interpreter is allowed to do,
and is decremented on each recursive call.}

The evaluation function is defined with the following type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\D{Fuel}\;\rightarrow\;\D{Program}\;\V{\Pi}\;\rightarrow\;\D{Env}\;\V{\Gamma}\;{}\<[E]%
\\
\>[11]{}\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}\;\rightarrow\;\D{Maybe}\;(\D{Env}\;\V{\Gamma'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The function \ensuremath{\F{run\textrm{-}step}} receives four arguments and returns a \ensuremath{\D{Maybe}} value. The
first argument is the \emph{fuel}, used to ensure the evaluator always terminates.
The second parameter is a \ensuremath{\D{Program}\;\V{\Pi}}, which contains information about all the
program blocks. The third parameter is the run-time variable environment. And the
last one is the \ensuremath{\D{Block}} to be evaluated. This function returns a modified run-time
environment (\ensuremath{\D{Env}\;\V{\Gamma'}}) in case of success, or nothing when the \emph{fuel} runs out.

From now on we describe how we implement some parts\footnote{The complete evaluation
function can be found in our online repository.} of the dynamic semantics (reduction rules)
of the list-machine language in the function \ensuremath{\F{run\textrm{-}step}}. We mix the code with the explanation
to make it easier for the reader.

\paragraph{Out of fuel}{The interpreter stops abruptly when the \emph{fuel} counter
reaches \ensuremath{\Con{zero}}, and the \ensuremath{\F{run\textrm{-}step}} function returns \ensuremath{\Con{nothing}}. This definition makes our
evaluation function structurally recursive on the \emph{fuel} argument. }

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;\Con{zero}\;\V{p}\;\V{env}\;\V{b}\;\mathrel{=}\;\Con{nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

All the next pieces of code match the value \ensuremath{\Con{suc}\;\V{fuel}} for the first argument of \ensuremath{\F{run\textrm{-}step}},
meaning that there is still \emph{fuel} during the recursive processing of this function.

%run-step (suc n) p env block-halt = just env
%run-step (suc n) p env (block-seq (instr-seq i₁ i₂) b) =
%  run-step n p env (block-seq i₁ (block-seq i₂ b))
%run-step {Π} (suc n) p env (block-seq (instr-branch-list {τ} {i} v l s) b)
%  with lookup env v 
%... | []v rewrite sym ([]=⇒lookup l) =
%  run-step n p (⊂-Ctx s (update-env env v nil)) (lookupA i p)
%... | v₁ ∷v v₂ = run-step n p (update-env env v (v₁ ∷ v₂)) b
%run-step (suc n) p env (block-seq (instr-branch-listcons v l s) b) =
% run-step n p env b

\paragraph{Conditional jump}{We show next only the case when the jump actually occurs,
following the rule \emph{step-branch-taken}. In this case, variable \ensuremath{\V{v}} has value \ensuremath{\Con{nil}}, and
the step of evaluation should proceed with the block instruction defined in program \ensuremath{\V{p}}, with
environment \ensuremath{\V{env}} respecting the subtyping constraint. We use the function \ensuremath{\F{lookupA}} to obtain
the block instruction with index \ensuremath{\V{i}} on program \ensuremath{\V{p}}. Since we use \emph{de Bruijn} indices to
represent the label, only valid values are accepted by the intrinsically-typed syntax.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}branch\textrm{-}nil}\;\{\mskip1.5mu \V{l}\;\mathrel{=}\;\V{i}\mskip1.5mu\}\;\V{v}\;\V{l}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{rewrite}\;\D{sym}\;(\F{[]\textrm{=}{\Rightarrow}lookup}\;\V{l})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{\subset\hspace{-3pt}\textrm{-}Ctx}\;\V{s}\;\V{env})\;(\F{lookupA}\;\V{i}\;\V{p}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Fetching list information}{The next code shows the evaluation of two syntactical constructors,
both related to the \emph{step-fetch-field-0} rule. The first retrieves the head element of a list, and
stores it in a new variable. The \ensuremath{\F{lookup}} function projects the value of variable \ensuremath{\V{v}} from the run-time
environment \ensuremath{\V{env}}, and this variable is added to the result environment. The typed \emph{de Bruijn}
indices guarantee that the projected value has the type demanded, since the environment \ensuremath{\V{env}} is typed
by the context \ensuremath{\V{\Gamma}}. Similarly, the second instruction also retrieves the head element of a list, however
it needs to update the run-time environment on the position of index \ensuremath{\V{v'}}. This process is done by the
function \ensuremath{\F{update\textrm{-}env}}.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;\V{v})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\V{v₁}\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;\V{v}\;\V{v'})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v'}\;\V{v₁})\;\V{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%run-step (suc n) p env (block-seq (instr-fetch-1-new v) b)
%  with lookup env v
%...| v₁ ∷ v₂ = run-step n p (v₂ ∷ env) b
%run-step (suc n) p env (block-seq (instr-fetch-1-upd v v') b)
%  with lookup env v
%...| v₁ ∷ v₂ = run-step n p (update-env env v' v₂) b

\paragraph{List creation}{To evaluate the instruction which creates a new list and respect the expected
types, we need some extra lemmas. First because when we create a list from variables \ensuremath{\V{v₀}} and \ensuremath{\V{v₁}}, the
result type of this list is the least common subtype between these two. As before, we use the \ensuremath{\F{lookup}}
function to retrieve the type information using the \emph{de Bruijn} indices of both variables, and we
extend the run-time environment \ensuremath{\V{env}} with the type of the created list. To convince the Agda's
type-checker the new environment is well-typed we use subtyping lemmas, such as \ensuremath{\F{\textrm{<:-}val}} and \ensuremath{\F{list\textrm{-<:-}inv}},
and others lemmas to deal with the least common subtying, such as \ensuremath{\F{lub\textrm{-}subtype\textrm{-}left}}, \ensuremath{\F{lub\textrm{-}subtype\textrm{-}right}},
and \ensuremath{\F{lub\textrm{-}of\textrm{-}subtype}}. These lemmas and their proofs can be found in our repository online. }

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}cons\textrm{-}new}\;\V{v₀}\;\V{v₁}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;((\F{\textrm{<:-}val}\;(\F{list\textrm{-<:-}inv}\;(\F{lub\textrm{-}subtype\textrm{-}left}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\F{lub\textrm{-}of\textrm{-}subtype}\;(\F{lub\textrm{-}subtype\textrm{-}left}\;\V{s}))))\;(\F{lookup}\;\V{env}\;\V{v₀}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{::}\;\F{\textrm{<:-}val}\;(\F{lub\textrm{-}subtype\textrm{-}right}\;\V{s})\;(\F{lookup}\;\V{env}\;\V{v₁}))\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It is worth noticing that we do not have any error treatment on this interpreter function, except for
when we ran out-of-fuel. Since we are using an intrinsically-typed syntax, only valid instructions
are accepted in each step of evaluation.

%run-step (suc n) p env (block-seq (instr-cons-upd v₀ v₁ v' s) b)
%  = run-step n p (update-env env v' (<:-val (list-<:-inv
%    (lub-subtype-left (lub-of-subtype (lub-subtype-left s))))
%    (lookup env v₀) ∷ <:-val (lub-subtype-right s)
%    (lookup env v₁))) b
%run-step (suc n) p env (block-jump {l = i} l s)
%  rewrite sym ([]=⇒lookup l) =
%    run-step n p (⊂-Ctx s env) (lookupA i p) 

\paragraph{Soundness properties}{Programs written using an intrinsically-typed syntax are type-sound by
construction. Since only well-typed programs can be expressed, the \emph{preservation} property is
enforced by the host-language type-checker~\cite{Amin17}. By implementing the interpreter in such a
total language like Agda, i.e., specifying the dynamic semantics in a functional way, instead of
relational, we also show the \emph{progress} property, without the need for an extra proof~\cite{Owens2016}.
This approach is promising to be investigated when formalizing even more complex programming languages.}

\section{Type Checker}\label{sec:typechecker}

In practice, a source-code of a programming language runs through several phases, including lexing, parsing,
scope checking, and most importantly \emph{type checking}. This sections deals with scope and type checking.
Since we represent programs using a intrinsically-typed syntax, scope and type checking is only a matter of
elaborating an untyped syntax to a typed one.


Since we use \emph{de Bruijn} indices to represent labels and variables, the first step to type and scope
check them, we need to provide an index from a named variable. This process is done by the \ensuremath{\F{lookup\textrm{-}var}} function.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lookup\textrm{-}var}\;{}\<[13]%
\>[13]{}\mathbin{:}\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\rightarrow\;(\V{x}\;\mathbin{:}\;\D{String})\;{}\<[E]%
\\
\>[13]{}\rightarrow\;\D{Maybe}\;(\D{\exists}\;\lambda\;\V{\tau}\;\rightarrow\;(\V{x}\;\red{,}\,\;\V{\tau})\;\D{\in}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\F{lookup\textrm{-}var}\;\Con{\lbrack\:\rbrack}\;\V{x}\;\mathrel{=}\;\Con{nothing}{}\<[E]%
\\
\>[B]{}\F{lookup\textrm{-}var}\;((\V{y}\;\red{,}\,\;\V{\tau})\;\Con{::}\;\V{\Gamma})\;\V{x}\;\mathkw{with}\;\V{x}\;\D{=}\;\V{y}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{yes}\;\Con{refl}\;\mathrel{=}\;\Con{just}\;(\V{\tau}\;\red{,}\,\;\Con{here}\;\Con{refl}){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;(\Con{no}\;\V{¬p})\;\mathrel{=}\;\F{map}\;{}\<[22]%
\>[22]{}(\lambda\;\V{v}\;\rightarrow\;\D{proj_1}\;\V{v}\;\red{,}\,\;\Con{there}\;(\D{proj_2}\;\V{v}))\;{}\<[E]%
\\
\>[22]{}(\F{lookup\textrm{-}var}\;\V{\Gamma}\;\V{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks



For space reasons, we show how we type check only one instruction. Function \ensuremath{\F{check\textrm{-}fetch\textrm{-}field\textrm{-}0}}
receives a program context, a typing context, and two named variables, and returns a \ensuremath{\D{TC}} value,
which is an error message or a \ensuremath{\D{CheckedInstr}} indicating that the term type checks.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{check\textrm{-}fetch\textrm{-}field\textrm{-}0}\;\mathbin{:}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;\rightarrow\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\rightarrow\;(\V{v}\;\mathbin{:}\;\D{String})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\rightarrow\;(\V{v'}\;\mathbin{:}\;\D{String})\;\rightarrow\;\D{TC}\;(\D{CheckedInstr}\;\V{\Pi}\;\V{\Gamma}\;(\Con{fetch\textrm{-}field\textrm{-}0}\;\V{v}\;\V{v'})){}\<[E]%
\\
\>[B]{}\F{check\textrm{-}fetch\textrm{-}field\textrm{-}0}\;\V{\Pi}\;\V{\Gamma}\;\V{v}\;\V{v'}\;\mathkw{with}\;\F{lookup\textrm{-}var}\;\V{\Gamma}\;\V{v}\;\red{,}\,\;\F{lookup\textrm{-}var}\;\V{\Gamma}\;\V{v'}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{nothing}\;\red{,}\,\;\anonymous \;\mathrel{=}\;\F{type\textrm{-}error}\;(\text{\ttfamily \char34 variable~out~of~scope:~\char34}\;\F{++}\;\V{v}){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{nil}\;\red{,}\,\;\anonymous )\;\red{,}\,\;\anonymous \;\mathrel{=}\;\F{type\textrm{-}error}\;\text{\ttfamily \char34 type~error\char34}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{list}\;\V{\tau}\;\red{,}\,\;\anonymous )\;\red{,}\,\;\anonymous \;\mathrel{=}\;\F{type\textrm{-}error}\;\text{\ttfamily \char34 type~error\char34}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{listcons}\;\V{\tau}\;\red{,}\,\;\V{idx})\;\red{,}\,\;{}\<[34]%
\>[34]{}\Con{nothing}\;\mathrel{=}\;{}\<[E]%
\\
\>[34]{}\Con{right}\;(\Con{ok}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;\V{idx})){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{listcons}\;\V{\tau}\;\red{,}\,\;\V{idx})\;\red{,}\,\;{}\<[34]%
\>[34]{}\Con{just}\;(\V{\tau'}\;\red{,}\,\;\V{idx'})\;\mathrel{=}\;{}\<[E]%
\\
\>[34]{}\Con{right}\;(\Con{ok}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;\V{idx}\;\V{idx'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the code above, we use the function \ensuremath{\F{lookup\textrm{-}var}} to provide the \emph{de Bruijn} indices for
each variable, and match the first with its possible forms. The first three cases indicate
type errors: (1) when \ensuremath{\V{v}} is \ensuremath{\Con{nothing}} it means an scope error; (2) and (3) are typing errors,
since the type of variable \ensuremath{\V{v}} should be a \ensuremath{\Con{listcons}}. Last two cases represent that the instruction
is well-typed. The process for type-checking different instructions follows a similar setting.

\section{Least common supertype}

\section{Related work}\label{sec:related}

\section{Conclusion}\label{sec:conclusion}



\bibliographystyle{ACM-Reference-Format}
\bibliography{main}
\end{document}
\endinput
