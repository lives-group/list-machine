\documentclass[review]{elsarticle}

\usepackage{lineno,hyperref}
\modulolinenumbers[5]



\usepackage{booktabs} % For formal tables
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{graphicx}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{ifpdf}
\usepackage{mathtools}
\usepackage{semantic}

\ifpdf
\usepackage{hyperref}
\fi
\usepackage{float}
\usepackage{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% color formatting stuff %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{Example}{Example}

\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff

%%%%%%%%%%%%%%%%%%%%
%% lhs2TeX stuff  %%
%%%%%%%%%%%%%%%%%%%%


%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\Con}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}




\journal{Journal of Computer Languages}


%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{An Intrinsically-Typed Solution for the\\ List-Machine Benchmark}

\author{Samuel Feitosa}
\ead{samuel.feitosa@ifsc.edu.br}
\address{%
  Departamento de Informática - Instituto Federal de Santa Catarina \\
  Caçador - Santa Catarina - Brazil
}

\author{Rodrigo Ribeiro}
\ead{rodrigo.ribeiro@ufop.edu.br}
\address{
  Prog. Pós Graduação em Ciência da Computação - Universidade Federal de Ouro Preto \\
  Ouro Preto - Minas Gerais - Brazil}


%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract          %%
%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Formal models are important tools in the programming language research
community. However, such models are full of intricacies and, due to that,
they are subject to subtle errors. Such failures motivated the usage of
tools to ensure the correctness of these formalisms. One way to eliminate
such errors is to encode models in a dependently-typed language in order
to ensure its ``correctness-by-construction''. In this paper, we use this
idea to build a verified interpreter for the list-machine benchmark in the
Agda programming language, comparing the results with formalizations developed
by Appel and Leroy. We formalize the 14 tasks of the benchmark
using roughly 14\% of LOC compared to a Twelf solution, and 47\% of LOC
compared to a Coq solution, even without the use of proof automation.
\end{abstract}


\begin{keyword}
Dependent types, formal semantics
\end{keyword}

\end{frontmatter}

\linenumbers



%%%%%%%%%%%%%%%%%%%%%%%
%% Introduction      %%
%%%%%%%%%%%%%%%%%%%%%%%



\section{Introduction}

The development of a new programming language design, linguistic construct,
or type system involves a careful formalization in order to express
its core ideas in a concise way. However, such models have many details
and complexities which can hinder its correctness assurances.
Because of such problems, the programming languages research community
started to use tools, like proof assistants~\cite{Stump16,Chlipala13},
and benchmark problems to validate them and stress its suitability for
such specification tasks~\cite{Aydemir05,Pientka18,Appel07}.

A popular approach for specifying formal semantics is the
use of definitional interpreters, which represents the meaning of a
programming language as an interpreter written in some
meta-language~\cite{Reynolds72}. A major advantage of such approach
is the possibility to validate the semantics through execution.
Recently, definitional interpreters were used for formalizing type
soundness theorems for some advanced typing features~\cite{Amin17},
and the semantics of imperative programming languages, in such a way the static
semantics is ensured by a dependently-typed
syntax\footnote{Also known as intrinsically-typed.}\cite{Poulsen18}.
In this work, we follow Poulsen et. al. by using an intrinsically-typed
representation to build a definitional interpreter for a low-level virtual
machine, developed by Appel and Leroy, as a benchmark problem closer to
real-world implementations such as typed assembly languages~\cite{CraryM99} and
proof-carrying code~\cite{Necula97}.

In this work, we extend our previous SBLP 2020 paper by including support to
indirect jumps, as specified in the version 2.0 of the list
machine benchmark~\cite{AppelDL12}. We provide detailed explanations of the needed
changes on the machine syntax, type system and interpreter to accomodate this extension, which
allows the handling of more complex control flow, like the call/return model of function calls.

More specifically, our contributions are:

\begin{itemize}
  \item We show how all the details of the list-machine type system
        can be encoded in a dependently-typed syntax setting, which avoids, by construction,
        the presence of stuck states in its definitional interpreter.
  \item We provide a provably correct implementation for testing the subtyping
        relation and to calculate the least common supertype of two input
        types for the machine registers.
  \item We provide a correct-by-construction implementation of a type-checker for
        list-machine programs. Our type-checker produces, as a result, an intrinsically-typed
        representation of the machine code.
  \item We compare the results of an intrinsic approach encoded in Agda with extrinsic
        formalizations encoded in Twelf and Coq. We show that such intrinsic encoding avoids
        unnecessary repetitions and provides some properties for free.
  \item We provide a detailed discussion on the necessary type system and interpreter modifications
        to support indirect jumps.
\end{itemize}

The rest of this paper is organized as follows: Section~\ref{sec:agda} presents an overview of
the Agda programming language and Section~\ref{sec:syntax}
gives a brief explanation about the encoding of dependently-typed syntax. Section~\ref{sec:list}
reviews the list-machine benchmark and presents its syntax and type system.
We describe the intrinsically-typed representation for the list-machine, as well as
the subtyping relation, and the least common supertype algorithm in Section~\ref{sec:typing}.
Section~\ref{sec:semantics} briefly discusses the list-machine semantics and
then proceeds with its realization as a definitional interpreter.
The type-checking algorithm is presented in Section~\ref{sec:typechecker}.
Section~\ref{sec:indirect} describes the necessary modifications in our formalization to
support indirect jumps, as proposed in the version 2.0 of the list machine benchmark.
Section~\ref{sec:comparison}
compares the presented formalization in Agda with Coq and Twelf encodings. Related work is
discussed in Section~\ref{sec:related}, and Section~\ref{sec:conclusion} concludes.

All the source code in this article has been formalized in Agda
version 2.6.1 using the Standard Library 1.3. All source code produced,
including the \LaTeX~source of this article, are available
on-line~\cite{list-rep}.


%%%%%%%%%%%%%%%%%%%%%%%
%% Overview of Agda  %%
%%%%%%%%%%%%%%%%%%%%%%%

\section{An overview of the Agda programming language}\label{sec:agda}



Agda is a dependently-typed functional programming language based on
Martin-L\"of intuitionistic type theory~\cite{Lof98}.  Function types
and an infinite hierarchy of types of types, \ensuremath{\D{Set}\;\V{l}}, where \ensuremath{\V{l}} is a
natural number, are built-in. Everything else is a user-defined
type. The type \ensuremath{\D{Set}}, also known as \ensuremath{\D{Set}_{\D{0}}}, is the type of all
``small'' types, such as \ensuremath{\D{Bool}}, \ensuremath{\D{String}} and \ensuremath{\D{List}\;\D{Bool}}.  The type
\ensuremath{\D{Set}_{\D{1}}} is the type of \ensuremath{\D{Set}} and ``others like it'', such as \ensuremath{\D{Set}\;\to \;\D{Bool}},
\ensuremath{\D{String}\;\to \;\D{Set}}, and \ensuremath{\D{Set}\;\to \;\D{Set}}. We have that \ensuremath{\D{Set}\;\V{l}} is an
element of the type \ensuremath{\D{Set}\;(\V{l+1})}, for every $l \geq 0$. This
stratification of types is used to keep Agda consistent as a logical
theory~\cite{Sorensen2006}.

An ordinary (non-dependent) function type is written \ensuremath{\V{A}\;\to \;\V{B}} and a
dependent one is written \ensuremath{(\V{x}\;\mathbin{:}\;\V{A})\;\to \;\V{B}}, where type \ensuremath{\V{B}} depends on
\ensuremath{\V{x}}, or \ensuremath{\D{\forall}\;(\V{x}\;\mathbin{:}\;\V{A})\;\to \;\V{B}}. Agda allows the definition of \emph{implicit
parameters}, i.e.,  parameters whose values can be inferred from the
context, by surrounding them in curly braces: \ensuremath{\D{\forall}\;\{\mskip1.5mu \V{x}\;\mathbin{:}\;\V{A}\mskip1.5mu\}\;\to \;\V{B}}. To
avoid clutter, we'll omit implicit arguments from the source code
presentation. The reader can safely assume that every free variable in
a type is an implicit parameter.

As an example of Agda code, consider the following data type of
length-indexed lists, also known as vectors.

 \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{\mathbb{N}}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Con{zero}\;\mathbin{:}\;\D{\mathbb{N}}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Con{suc}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{\mathbb{N}}{}\<[E]%
\\[\blanklineskip]%
\>[4]{}\mathkw{data}\;\D{Vec}\;(\V{A}\;\mathbin{:}\;\D{Set})\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Con{\lbrack\:\rbrack}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\D{Vec}\;\V{A}\;\Con{zero}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\V{A}\;\to \;\D{Vec}\;\V{A}\;\V{n}\;\to \;\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


Constructor \ensuremath{\Con{\lbrack\:\rbrack}} builds empty vectors. The cons-operator (\ensuremath{\Con{\_::\_}})
inserts a new element in front of a vector of $n$ elements (of type
\ensuremath{\D{Vec}\;\V{A}\;\V{n}}) and returns a value of type \ensuremath{\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})}. The
\ensuremath{\D{Vec}} datatype is an example of a dependent type, i.e., a type
that uses a value (that denotes its length). The usefulness of
dependent types can be illustrated with the definition of a safe list
head function: \ensuremath{\F{head}} can be defined to accept only non-empty
vectors, i.e.,~values of type \ensuremath{\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{head}\;\mathbin{:}\;\D{Vec}\;\V{A}\;(\Con{suc}\;\V{n})\;\to \;\V{A}{}\<[E]%
\\
\>[3]{}\F{head}\;(\V{x}\;\Con{::}\;\V{xs})\;\mathrel{=}\;\V{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In \ensuremath{\F{head}}'s definition, constructor \ensuremath{\Con{\lbrack\:\rbrack}} is not used. The
Agda type-checker can figure out, from \ensuremath{\F{head}}'s parameter type,
that argument \ensuremath{\Con{\lbrack\:\rbrack}} to \ensuremath{\F{head}} is not type-correct.



Another useful data type is the finite type,
\ensuremath{\D{Fin}}\footnote{Note that Agda supports the overloading of
data type constructor names. Constructor \ensuremath{\Con{zero}} can refer to
type \ensuremath{\D{\mathbb{N}}} or \ensuremath{\D{Fin}}, depending on the context where the name
is used.}, which is defined in Agda's standard library as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{Fin}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{zero}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;(\Con{suc}\;\V{n}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{suc}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{Fin}\;(\Con{suc}\;\V{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Type \ensuremath{\D{Fin}\;\V{n}} has exactly \ensuremath{\V{n}} inhabitants
(elements), i.e., it is isomorphic to the set $\{0,...,n - 1\}$.
An application of such type is to define a safe vector
lookup function, which avoids the access of invalid positions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\F{lookup}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{A}\;\V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{Vec}\;\V{A}\;\V{n}\;\to \;\V{A}{}\<[E]%
\\
\>[3]{}\F{lookup}\;\Con{zero}\;(\V{x}\;\Con{::}\;\anonymous )\;\mathrel{=}\;\V{x}{}\<[E]%
\\
\>[3]{}\F{lookup}\;(\Con{suc}\;\V{idx})\;(\anonymous \;\Con{::}\;\V{xs})\;\mathrel{=}\;\F{lookup}\;\V{idx}\;\V{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Thanks to the propositions-as-types principle,\footnote{It is also known as
Curry-Howard ``isomorphism''~\cite{Sorensen2006}.} we can interpret
types as logical formulas and terms as proofs. An example is the
representation of equality as the following Agda type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{\_ \equiv \_}\;\{\mskip1.5mu \V{l}\mskip1.5mu\}\;\{\mskip1.5mu \V{A}\;\mathbin{:}\;\D{Set}\;\V{l}\mskip1.5mu\}\;(\V{x}\;\mathbin{:}\;\V{A})\;\mathbin{:}\;\V{A}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{refl}\;\mathbin{:}\;\V{x}\;\D{\equiv}\;\V{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This type is called propositional equality. It defines that there is
a unique evidence for equality, constructor \ensuremath{\Con{refl}} (for reflexivity),
which asserts that the only value equal to \ensuremath{\V{x}} is itself. Given a predicate \ensuremath{\V{P}\;\mathbin{:}\;\V{A}\;\to \;\D{Set}}
and a vector \ensuremath{\V{xs}}, the type \ensuremath{\D{All}\;\V{P}\;\V{xs}} is used to build proofs that \ensuremath{\V{P}} holds for all
elements in \ensuremath{\V{xs}} and it is defined as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathkw{data}\;\D{All}\;(\V{P}\;\mathbin{:}\;\V{A}\;\to \;\D{Set})\;\mathbin{:}\;\D{Vec}\;\V{A}\;\V{n}\;\to \;{}\<[41]%
\>[41]{}\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{\lbrack\:\rbrack}\;\mathbin{:}\;\D{All}\;\V{P}\;\Con{\lbrack\:\rbrack}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{x}\;\V{xs}\mskip1.5mu\}\;\to \;\V{P}\;\V{x}\;\to \;\D{All}\;\V{P}\;\V{xs}\;\to \;\D{All}\;\V{P}\;(\V{x}\;\Con{::}\;\V{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The first constructor specifies that \ensuremath{\D{All}\;\V{P}} holds for the empty vector and
constructor \ensuremath{\Con{\_::\_}} builds a proof of \ensuremath{\D{All}\;\V{P}\;(\V{x}\;\Con{::}\;\V{xs})} from proofs of
\ensuremath{\V{P}\;\V{x}} and \ensuremath{\D{All}\;\V{P}\;\V{xs}}. Since this type has the same structure of vectors,
some functions on \ensuremath{\D{Vec}} have similar definitions for type \ensuremath{\D{All}}. As an example
used in our formalization, consider the function \ensuremath{\F{lookup}}, which extracts a
proof of \ensuremath{\V{P}} for the element at position \ensuremath{\V{v}\;\mathbin{:}\;\D{Fin}\;\V{n}} in a \ensuremath{\D{Vec}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\F{lookup}\;\mathbin{:}\;\{\mskip1.5mu \V{xs}\;\mathbin{:}\;\D{Vec}\;\V{A}\;\V{n}\mskip1.5mu\}\;\to \;\D{Fin}\;\V{n}\;\to \;\D{All}\;\V{P}\;\V{xs}\;\to \;\V{P}\;\V{x}{}\<[E]%
\\
\>[4]{}\F{lookup}\;\Con{zero}\;(\V{px}\;\Con{::}\;\anonymous )\;\mathrel{=}\;\V{px}{}\<[E]%
\\
\>[4]{}\F{lookup}\;(\Con{suc}\;\V{idx})\;(\anonymous \;\Con{::}\;\V{pxs})\;\mathrel{=}\;\F{lookup}\;\V{idx}\;\V{pxs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\section{Dependently-typed Syntax}\label{sec:syntax}


An important application of dependent types is to encode programming languages
syntax. The role of dependent types in this domain is to encode programs that
only allow well-typed and well-scoped terms~\cite{Benton2012}. Intuitively, we encode
the static semantics of the object language in the host language AST's
constructor, leaving the responsibility of checking type safety to the
host's language type-checker. As an example, consider the following simple
expression language. For this paper, we assume a basic knowledge of functional
programming and Agda. %\footnote{For further information about Agda, see~\cite{Norell2009,Stump16}.}.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{Expr}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{True}\;\Con{False}\;\mathbin{:}\;\D{Expr}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Num}\;\mathbin{:}\;\D{\mathbb{N}}\;\to \;\D{Expr}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_\land\_}\;\Con{\_+\_}\;\mathbin{:}\;\D{Expr}\;\to \;\D{Expr}\;\to \;\D{Expr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using this data type\footnote{Agda supports the definition of mixfix operators.
We can use underscores to mark arguments positions.}, we can construct expressions
to denote terms that should not be considered well-typed like
\ensuremath{(\Con{Num}\;\V{1})\;\F{+}\;\Con{True}}. Using this approach, we need to specify the static semantics
as another definition, which should consider all possible cases to avoid the
definition of ill-typed terms.

A better approach is to combine the static semantics and language syntax into
a single definition, as shown below.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Nat}\;\Con{Bool}\;\mathbin{:}\;\D{Ty}{}\<[E]%
\\[\blanklineskip]%
\>[4]{}\mathkw{data}\;\D{Expr}\;\mathbin{:}\;\D{Ty}\;\to \;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{True}\;\Con{False}\;\mathbin{:}\;\D{Expr}\;\Con{Bool}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{Num}\;\mathbin{:}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_\land\_}\;\mathbin{:}\;\D{Expr}\;\Con{Bool}\;\to \;\D{Expr}\;\Con{Bool}\;\to \;\D{Expr}\;\Con{Bool}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Con{\_+\_}\;\mathbin{:}\;\D{Expr}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}\;\to \;\D{Expr}\;\Con{Nat}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In this definition, the \ensuremath{\D{Expr}} type is indexed by a value of type \ensuremath{\D{Ty}} which
indicates the type of the expression being built. In this approach, Agda's
type system can enforce that only well-typed terms could be written.
%A definition which uses the expression |(Num 1) + True| will be rejected by Agda's type checker automatically.
Agda's type-checker will automatically reject a definition which uses the expression \ensuremath{(\Con{Num}\;\V{1})\;\F{+}\;\Con{True}}.

For further information about Agda, see~\cite{Norell2009,Stump16}.

%Dependently typed pattern matching is built by using the so-called
%|with| construct, that allows for matching intermediate
%values~\cite{McBride2004}. If the matched value has a dependent type,
%then its result can affect the form of other values. For example,
%consider the following code that defines a type for natural number
%parity. If the natural number is even, it can be represented as the
%sum of two equal natural numbers; if it is odd, it is equal to one
%plus the sum of two equal values. Pattern matching on a value of
%|Parity n| allows to discover if $n = j + j$ or $n = S (k + k)$,
%for some $j$ and $k$ in each branch of |with|.  Note that the
%value of $n$ is specialized accordingly, using information ``learned''
%by the type-checker.
%\begin{spec}
%data Parity : Nat -> Set where
%   Even : forall {n : Nat} -> Parity (n + n)
%   Odd  : forall {n : Nat} -> Parity (S (n + n))
%
%parity : (n : Nat) -> Parity n
%parity = -- definition omitted

%natToBin : Nat -> List Bool
%natToBin zero = []
%natToBin k with (parity k)
%   natToBin (j + j)     | Even = false :: natToBin j
%   natToBin (succ (j + j)) | Odd  = true  :: natToBin j
%\end{spec}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% List-machine benchmark %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{The List-Machine Benchmark}\label{sec:list}

The list-machine, proposed by Appel et. al.~\cite{AppelDL12}, is a simple pointer virtual machine where values
are empty lists and cons-cells:
\[
a ::= nil\,\mid\,cons(a_1,a_2)
\]
Throughout this text, the meta-variable $a$ is used to denote an arbitrary value, $v$ denotes a variable
and $l$ a program label. Following common practice, all meta-variables can
appear primed or subscripted. The syntax of the virtual machine instructions are
presented next and their meaning is as usual.
\[
\begin{array}{rcll}
  \iota & ::=  & \text{jump }l                       & \text{(jump instruction)}\\
        & \mid & \text{branch-if-nil $v$~$l$}            & \text{(if $v = nil$ goto $l$)}\\
        & \mid & \text{fetch-field $v$ 0 $v'$}       & \text{(fetch the head of $v$ into $v'$)}\\
        & \mid & \text{fetch-field  $v$ 1 $v'$}      & \text{(fetch the tail of $v$ into $v'$)}\\
        & \mid & \text{cons $v_0$ $v_1$ $v'$}        & \text{(make a cons cell in v')} \\
        & \mid & \text{halt}                         & \text{(finishes execution)}\\
        & \mid & \iota_1;\iota_2                             & \text{(sequential composition)}\\
      p & ::=  & l_i \,:\,\iota\,;\,p                    & \text{(program: sequence of blocks)}\\
        & \mid & \text{end}                          & \text{(end of block list)}\\
\end{array}
\]
A program is just a sequence of blocks referenced by a unique label.

Each program variable is assigned to a list type, which is used to guarantee the safety when executing
fetch-field instructions that demands non-empty list arguments. In order to express such refinements, types are subject to a
subtyping relation. The meta-variable $\tau$ denotes an arbitrary type.
\[
\begin{array}{rcll}
  \tau & ::=  & \text{nil} & \text{(type for empty lists)}\\
       & \mid & \text{list }\tau & \text{(lists whose elements have type $\tau$)}\\
       & \mid & \text{listcons }\tau & \text{(non-empty lists of $\tau$)}\\
\end{array}
\]
The notation $\tau \subset \tau'$
denotes the subtyping judgment, which is defined as follows.
\[
\begin{array}{ccc}
  \inference{}
            {\tau\subset \tau}
            [refl]
  &
  \inference{}
            {nil \subset \tau}
            [nil]
  &
  \inference{\tau \subset \tau'}
            {list\:\tau\subset list\:\tau'}
            [list]\\\\
  \multicolumn{3}{c}{
  \inference{\tau \subset \tau'}
            {listcons\:\tau\subset list\:\tau'}
            [listcons]} \\\\
            \multicolumn{3}{c}{
            \inference{\tau \subset \tau'}
            {listcons\:\tau\subset listcons\:\tau'}
            [mixed]} \\\\
\end{array}
\]
Basically, the subtyping relation specifies that $nil$ (empty list type) is
subtype of any list type and $listcons\:\tau$ is a subtype of the $list\:\tau$.
The other rules specify that type constructors $list$ and $listcons$ respect
the subtyping relation. The list common supertype $\tau = \tau_1 \sqcap \tau_2$ of
$\tau_1$ and $\tau_2$ is defined as the smallest type such that $\tau_1$ and $\tau_2$
are subtypes of $\tau$.

Following common practice, the meta-variable $\Gamma$ denotes an
environment binding variable names to their types. Notation $\{\}$ denotes an empty environment, $v : \tau , \Gamma$
denotes the operation of including a new entry for variable $v$ with type $\tau$
in $\Gamma$ and $\Gamma [v := \tau]$ denotes the environment which is identical to $\Gamma$, except
by the entry which associates variable $v$ with type $\tau$.
Subtyping is extended to contexts as follows.
\[
\begin{array}{cc}
  \inference{}
            {\Gamma \subset_{env} \{\}}[b1]
  &
  \inference{\tau' \subset \tau & \Gamma' \subset_{env} \Gamma_2}
            {v : \tau' , \Gamma' \subset_{env} v : \tau , \Gamma_2}
            [b2]
\end{array}
\]
The variable $\Pi$ is used to denote \emph{program typings}, i.e. finite mappings between
labels and typing contexts $\Gamma$, where notation $\Pi(l) = \Gamma$ denotes that
$\Gamma$ stores the types of variables on the entry point of the block labeled by $l$.
Using the previously defined notations, the typing rules for the list-machine are defined
as a syntax directed judgment $\Pi \vdash_{\text{instr}} \Gamma \{ \iota \} \Gamma'$,
which intuitively means that the instruction $\iota$ transforms an input typing environment
$\Gamma$ into an output environment $\Gamma'$ under a fixed program typing $\Pi$. The typing
rules for the list-machine instructions are defined as follows.

The first typing rule we consider is the one for sequencing instructions inside a block. Basically,
the rule just threads the output environment from the first instruction as the input typing for the
second.
\[
\inference{\Pi \vdash_{\text{instr}} \Gamma\{ \iota_1 \}\Gamma'\:\:\:\:\:\:\:\:\Pi \vdash_{\text{instr}} \Gamma'\{ \iota_2 \}\Gamma''}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \iota_1 ; \iota_2 \}\Gamma''}[seq]
\]
The type system proposed by Appel et. al.~\cite{AppelDL12} has three rules to deal with each of the possible
types assigned to the branch variable in the current typing context. The first two rules deal with the $list$ and $listcon$
types, specifying that the environment associated to the label $l$, $\Pi(l) = \Gamma_1$, is greater than
$\Gamma[v := nil]$. The third rule applies whenever $\Gamma(v) = nil$ and it also demands that $\Gamma \subset \Pi(l)$.

\[
\begin{array}{c}
\inference{\Gamma(v) = \text{list}~\tau\:\:\:\:\:\:\:\:\Pi(l) = \Gamma_1\\
                     \Gamma[v:=\text{nil}]=\Gamma'\:\:\:\:\:\:\:\:\Gamma' \subset_{env} \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}(v: \text{listcons}~\tau,~\Gamma')}
          [branch-list]
\\ \\

\inference{\Gamma(v) = \text{listcons}~\tau\:\:\:\:\:\:\:\:\Pi(l) = \Gamma_1\\
           \Gamma[v:=\text{nil}]=\Gamma'\:\:\:\:\:\:\:\:\Gamma' \subset_{env} \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}\Gamma}[branch-listcons]

\\ \\
\inference{\Gamma(v) = \text{nil}\:\:\:\:\Pi(l) = \Gamma_1\:\:\:\:\Gamma \subset \Gamma_1}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{branch-if-nil}~v~l \}\Gamma}
          [branch-nil]
\end{array}
\]
Next, we have the \emph{fetch} instructions, which can be used to store the head / tail of a list value in
a variable. Rule \emph{fetch-0} retrieves the head of a value stored in a variable $v$ and \emph{fetch-1}
does the same for the tail. Note that both rules demand that $\Gamma(v) = listcons\:\tau$, for some type
$\tau$.
\[
\begin{array}{c}
\inference{\Gamma(v) = \text{listcons}~\tau\:\:\:\:\Gamma[v':=\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{fetch-field}~v~0~v' \}\Gamma'}[fetch-0]
          \\ \\
\inference{\Gamma(v) = \text{listcons}~\tau\:\:\:\:\Gamma[v':=\text{list}~\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{fetch-field}~v~1~v' \}\Gamma'}[fetch-1]
\end{array}
\]
The \emph{cons} instruction allows us to build a non-empty list value and this rule uses the least
common supertype operator to check if the result of the operation is really a list type.
\[
\inference{\Gamma(v_0) = \tau_0\:\:\:\:\:\:\:\:\Gamma(v_1) = \tau_1 \\
           (\text{list}~\tau_0) \sqcap \tau_1=\text{list}~\tau\:\:\:\:\:\:\:\:\Gamma[v:=\text{listcons}~\tau]=\Gamma'}
          {\Pi \vdash_{\text{instr}} \Gamma\{ \textbf{cons}~v_0~v_1~v \}\Gamma'}[cons]
\]
The final rules deal with the well-formedness of blocks and programs. The typing rules for the \textbf{halt} instruction and
program \textbf{end} are completely trivial. Rule \emph{block-seq} does the typing context threading between sequential
instructions inside a block and rule \emph{block-label} recursively applies the judgment $\vdash_{block}$ on the
input program.

\[
\begin{array}{cc}
   \inference{}
             {\Pi;\Gamma\vdash_{\text{block}} \textbf{halt}}[halt]
   &
   \inference{}
             {\Pi\vdash_{\text{blocks}} \textbf{end}}[empty]\\ \\

   \inference{\Pi(l)=\Gamma_1\\ \Gamma \subset_{env} \Gamma_1}
             {\Pi;\Gamma\vdash_{\text{block}} \textbf{jump}~l}[jump]

   &

   \inference{\Pi\vdash_{\text{instr}} \Gamma\{\iota_1\}\Gamma'\\ \Pi;\Gamma'\vdash_{\text{block}} \iota_2}
             {\Pi;\Gamma\vdash_{\text{block}} \iota_1;\iota_2}[block-seq]
 \\ \\

   \multicolumn{2}{c}{
   \inference{\Pi(l)=\Gamma\:\:\:\:\:\:\:\:\Pi;\Gamma\vdash_{\text{block}} \iota\:\:\:\:\:\:\:\:\Pi\vdash_{\text{blocks}} p}
     {\Pi\vdash_{\text{blocks}} l: \iota;~p}[blocks-label]
    }
\end{array}
\]
Inspired by the presented typing rules, in the next section, we define an
intrinsically-typed syntax for list-machine programs which ensures that
only well-typed programs can be built.

\section{Intrinsically-typed syntax}\label{sec:typing}


In this section we introduce the design choices and the steps we took to represent the
intrinsically-typed syntax for the list-machine benchmark. We present here the Agda
code used in our definitions, not necessarily in a strict lexically-scoped order.

Some definitions and rules have been slightly tweaked so that they are accepted by
the Agda's type-checker. As a design choice, we dropped all names, using
\emph{de Bruijn} indices~\cite{DEBRUIJN72} to represent both \emph{name bindings}
for labels and variables. This way, we guarantee that names are always well-scoped.

We started our formalization by defining a type \ensuremath{\D{Ty}}, indicating the possible types
for the list-machine language.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{list}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{listcons}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We internalize the list-machine type judgments for blocks and instructions in Agda
together with its syntax in such a way that only well-typed terms that satisfy typing
judgments have meaning. This approach makes the AST contain both syntactic and semantic
properties.

In order to be considered well-typed, list-machine programs need to refer
to information from two sources: (1) a type context encoded as a list to store
variable types; and (2) a program context encoded as a vector\footnote{We use the
\ensuremath{\D{Vec}} datatype indexed by an \ensuremath{\V{n}} which is bound on the module definition and represents
the number of labels in the current program.} of type contexts to represent the types of
the variables on entry to each basic block.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Ctx}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Ctx}\;\mathrel{=}\;\D{List}\;(\D{String}\;\V{×}\;\D{Ty}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\D{PCtx}\;\mathbin{:}\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{PCtx}\;\mathrel{=}\;\D{Vec}\;\D{Ctx}\;\V{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


As we saw in the previous section, the typing rules for the list-machine language were split
into two segments, one for instructions and one for blocks. We define two datatypes (\ensuremath{\D{\_\vdash\_\Rightarrow\_}} and \ensuremath{\D{Block}})
to hold the well-typed terms accordingly, representing each judgment of the static semantics as a
syntactical constructor. In Agda we use \emph{indexed inductive types} to define an intrinsically-typed syntax.
The basic idea is to represent each type system rule as a constructor typed by an output context.
Such representation scheme makes the Agda's type-checker allow only well-typed blocks and
instructions to be created and manipulated.


%Both definitions are \emph{parameterized} by a program context and a typing context, and
%\emph{indexed}\footnote{An index can vary in the result types of the different constructors,
%while a parameter cannot.} by a resulting typing context. The intuition is that, under
%program-typing |Π|, the \emph{Hoare triple} |Γ{ι}Γ'| relates precondition |Γ| to
%postcondition |Γ'|. It is important to note that instead of manipulating syntax directly,
%the meta-program manipulates structures representing the type judgments as well.
%Such
%representation scheme makes the Agda's type-checker allow only well-typed blocks and
%instructions to be created and manipulated.

The representation of instructions is defined as follows.




\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{\_\vdash\_\Rightarrow\_}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}seq}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\;\V{\Gamma''}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma'}\;\D{\Rightarrow}\;\V{\Gamma''}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma''}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}list}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{l}\;\V{\Gamma'}\;\V{x}\mskip1.5mu\}\;\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x}\;\red{,}\,\;\Con{list}\;\V{\tau})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma'}\;\rightarrow\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{nil}))\;\D{\subset}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}listcons}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{l}\;\V{\Gamma_1}\;\V{x}\mskip1.5mu\}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;\rightarrow\;(\V{idx}\;\F{::=}\;(\V{x}\;\red{,}\,\;\Con{nil}))\;\D{\subset}\;\V{\Gamma_1}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}branch\textrm{-}nil}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma_1}\;\V{l}\;\V{x}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{nil})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;\rightarrow\;\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau'}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\Con{list}\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau'}\;\V{x}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\Con{list}\;\V{\tau})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}cons\textrm{-}new}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau_0}\;\V{\tau_1}\;\V{x₀}\;\V{x₁}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}\;\rightarrow\;\Con{list}\;\V{\tau_0}\;\D{\sqcap}\;\V{\tau_1}\;\D{\sim}\;\Con{list}\;\V{\tau}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;((\V{x'}\;\red{,}\,\;\Con{listcons}\;\V{\tau})\;\Con{::}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{instr\textrm{-}cons\textrm{-}upd}\;{}\<[26]%
\>[26]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\tau}\;\V{\tau_0}\;\V{\tau_1}\;\V{\tau_2}\;\V{x₀}\;\V{x₁}\;\V{x'}\mskip1.5mu\}\;\rightarrow\;(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}\;\rightarrow\;(\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau_2})\;\D{\in}\;\V{\Gamma})\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\Con{list}\;\V{\tau_0}\;\D{\sqcap}\;\V{\tau_1}\;\D{\sim}\;\Con{list}\;\V{\tau}\;{}\<[E]%
\\
\>[26]{}\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;(\V{idx}\;\F{::=}\;(\V{x'}\;\red{,}\,\;\Con{listcons}\;\V{\tau})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


In our approach, all name binding is done with statically checked \emph{de Bruijn}
indices~\cite{DEBRUIJN72}, a technique for handling binding by using a nameless,
position-dependent naming scheme. For example, we use a well-typed \emph{de Bruijn}
index \ensuremath{(\V{x}\;\red{,}\,\;\V{\tau})\;\D{\in}\;\V{\Gamma}}, which witnesses the existence of an element \ensuremath{(\V{x}\;\red{,}\,\;\V{\tau})} in \ensuremath{\V{\Gamma}},
as defined by the standard library \ensuremath{\D{\_\hspace{-2pt}\in\hspace{-2pt}\_}} operator. This technique is well-known for
avoiding out-of-bound errors.

\paragraph{Sequencing instructions}{The constructor \ensuremath{\Con{instr\textrm{-}seq}} is used to
express a sequence of instructions. From the execution of two instructions, it
produces a modified typing context containing the changes performed by
both instructions.}

\paragraph{Conditional jump}{There are three constructors (\ensuremath{\Con{instr\textrm{-}branch\textrm{-}list}},
\ensuremath{\Con{instr\textrm{-}branch\textrm{-}listcons}}, and \ensuremath{\Con{instr\textrm{-}branch\textrm{-}nil}}) for expressing a conditional
jump. They are used to perform a jump to a label \ensuremath{\V{l}} when the received variable is \ensuremath{\Con{nil}}.
All these constructors type-check the typing context of the intended label with the
current typing context. We use \ensuremath{\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}}, meaning that there exist a typing context
\ensuremath{\V{\Gamma_1}} in program typing \ensuremath{\V{\Pi}} related to label \ensuremath{\V{l}}. And we use \ensuremath{\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}} as a proof of
subtyping between \ensuremath{\V{\Gamma}} and \ensuremath{\V{\Gamma_1}}. The operator \ensuremath{\F{\_\hspace{-2pt}::=\hspace{-2pt}\_}} is used to update the context \ensuremath{\V{\Gamma}}
in the position defined by the index \ensuremath{\V{idx}}.}

\paragraph{Fetching information from list}{There are four constructors for expressing
information fetching from a given list. The constructor \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}} receives a
non-empty list (of type \ensuremath{\Con{listcons}\;\V{\tau}}), and is used to retrieve the head of this list and store it
in a fresh new variable. The resulting typing context adds the information about the new
variable. Constructor \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}} is also used to retrieve the head element of a
list, however storing its value in an existing variable, represented by the \emph{de Bruijn}
index \ensuremath{\V{idx}\;\mathbin{:}\;(\V{x'}\;\red{,}\,\;\V{\tau'})\;\D{\in}\;\V{\Gamma}}. The constructors \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}new}} and \ensuremath{\Con{instr\textrm{-}fetch\textrm{-}1\textrm{-}upd}}
are similar, but fetching the tail of a list instead of the head.}


\paragraph{List construction}{The \ensuremath{\Con{instr\textrm{-}cons\textrm{-}new}} and \ensuremath{\Con{instr\textrm{-}cons\textrm{-}upd}} constructors are
used to create a new list. The first creates a new variable, and the second updates an
existing variable. The list is created from two variables, \ensuremath{(\V{x₀}\;\red{,}\,\;\V{\tau_0})\;\D{\in}\;\V{\Gamma}} and \ensuremath{(\V{x₁}\;\red{,}\,\;\V{\tau_1})\;\D{\in}\;\V{\Gamma}},
which are represented as \emph{de Bruijn} indices. The type of the new list is defined by
the least common supertype\footnote{A complete explanation about the least common supertype
can be found in the original list-machine paper~\cite{Appel07}.}, which is defined by the
type \ensuremath{\V{\tau_1}\;\D{\sqcap}\;\V{\tau_2}\;\D{\sim}\;\V{\tau}}, which encodes that the least common supertype of \ensuremath{\V{\tau_1}} and \ensuremath{\V{\tau_2}} is \ensuremath{\V{\tau}}.
The resulting typing context adds information about the newly created list.
Subsection~\ref{sec:supertype} provides the details of an algorithm
for calculating the least common supertype of two given types.}

%\footnote{The code of this definition is omitted here, but can be found
%in our online repository.}


The representation of blocks is defined as follows.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Block}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;{}\<[42]%
\>[42]{}\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}halt}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}seq}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\;\V{\Gamma''}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{\vdash}\;\V{\Gamma}\;\D{\Rightarrow}\;\V{\Gamma'}\;{}\<[E]%
\\
\>[15]{}\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma'}\;\V{\Gamma''}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma''}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{block\textrm{-}jump}\;{}\<[15]%
\>[15]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{l}\;\V{\Gamma_1}\;\V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\V{\Pi}\;\D{[}\;\V{l}\;\D{]=}\;\V{\Gamma_1}\;{}\<[E]%
\\
\>[15]{}\rightarrow\;\V{\Gamma}\;\D{\subset}\;\V{\Gamma_1}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Constructor \ensuremath{\Con{block\textrm{-}halt}} can be used to stop the execution of a given block, \ensuremath{\Con{block\textrm{-}seq}} has a
similar meaning to instruction sequence, and \ensuremath{\Con{block\textrm{-}jump}} is used to perform a direct jump
(without any condition), receiving a label and checking if the current context typing is a
subtype of the intended one.


And finally, a \ensuremath{\D{Program}} is a sequence of instruction blocks, each preceded by a label.
We use the \ensuremath{\D{All}} datatype to express this relation.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Program}\;\mathbin{:}\;\D{PCtx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Program}\;\V{\Pi}\;\mathrel{=}\;\D{\forall}\;\{\mskip1.5mu \V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\D{All}\;(\lambda\;\V{\Gamma}\;\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'})\;\V{\Pi}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Subtyping and least common supertype}\label{sec:supertype}


A key feature of the list-machine type system is its subtyping (denoted by \ensuremath{\D{<:}}), which is
exposed by the least common supertype relation. We omit the Agda encoding of the subtyping relation for
space reasons, since it is just an inductive type that encodes the rules presented
in Section~\ref{sec:list}. Several lemmas about subtyping, including its decidable test,
are defined in our source-code repository~\cite{list-rep}.

The least common supertype relation is used by the list-machine type system to refine a
variable type whenever it is updated by a \emph{cons} instruction. The rules of the
supertype relation are specified as the following inductive type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{\_\sqcap\_\sim\_}\;\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}\;\rightarrow\;\D{Ty}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{lub0}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\V{t}\;\D{\sqcap}\;\V{t}\;\D{\sim}\;\V{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{lub1}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;(\Con{list}\;\V{t})\;\D{\sqcap}\;\Con{nil}\;\D{\sim}\;(\Con{list}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{lub3}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\;\V{t1}\;\V{t'}\mskip1.5mu\}\;\rightarrow\;\V{t}\;\D{\sqcap}\;\V{t1}\;\D{\sim}\;\V{t'}\;\rightarrow\;{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}(\Con{list}\;\V{t})\;\D{\sqcap}\;(\Con{list}\;\V{t1})\;\D{\sim}\;(\Con{list}\;\V{t'}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{lub5}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;(\Con{listcons}\;\V{t})\;\D{\sqcap}\;\Con{nil}\;\D{\sim}\;(\Con{list}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{lub7}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\;\V{t1}\;\V{t'}\mskip1.5mu\}\;\rightarrow\;\V{t}\;\D{\sqcap}\;\V{t1}\;\D{\sim}\;\V{t'}\;\rightarrow\;{}\<[E]%
\\
\>[3]{}\hsindent{10}{}\<[13]%
\>[13]{}(\Con{listcons}\;\V{t})\;\D{\sqcap}\;(\Con{listcons}\;\V{t1})\;\D{\sim}\;(\Con{listcons}\;\V{t'}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\orange{\texttt{-- some code omitted for brevity}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The presented constructors ensure that the relation is compatible with \emph{list} and \emph{listcons}
types. Also, we have a rule to ensure that the relation is commutative, as proved by a simple
Agda theorem.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{\sqcap\textrm{-}comm}\;\mathbin{:}\;\V{t1}\;\D{\sqcap}\;\V{t2}\;\D{\sim}\;\V{t3}\;\rightarrow\;\V{t2}\;\D{\sqcap}\;\V{t1}\;\D{\sim}\;\V{t3}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We omit the complete definition of \ensuremath{\F{\sqcap\textrm{-}comm}} for brevity. In the list-machine benchmark definition,
Appel et. al.~\cite{AppelDL12} also define that the least common supertype relation is sound and complete with respect to the
subtyping relation. Again, we omit the definitions of these properties, however their types are presented below.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{\sqcap\textrm{-}subtype}\;\mathbin{:}\;\V{t1}\;\D{\sqcap}\;\V{t2}\;\D{\sim}\;\V{t3}\;\rightarrow\;(\V{t1}\;\D{<:}\;\V{t3})\;\D{\land}\;(\V{t2}\;\D{<:}\;\V{t3}){}\<[E]%
\\
\>[B]{}\F{\sqcap\textrm{-}least}\;\mathbin{:}\;\V{t1}\;\D{\sqcap}\;\V{t2}\;\D{\sim}\;\V{t3}\;\rightarrow\;\V{t1}\;\D{<:}\;\V{t3}\;\rightarrow\;\V{t2}\;\D{<:}\;\V{t4}\;\rightarrow\;\V{t3}\;\D{<:}\;\V{t4}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
An algorithm to construct the least supertype from two input types is
defined by function \ensuremath{\F{lub}}. Note that the \ensuremath{\F{lub}}'s type ensures that the
returned type \ensuremath{\V{t}} is indeed the least common supertype of \ensuremath{\V{t1}} and \ensuremath{\V{t2}},
thus ensuring its correctness-by-construction.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lub}\;\mathbin{:}\;(\V{t1}\;\V{t2}\;\mathbin{:}\;\D{Ty})\;\rightarrow\;\V{∃}\;(\lambda\;\V{t}\;\rightarrow\;\V{t1}\;\D{\sqcap}\;\V{t2}\;\D{\sim}\;\V{t}){}\<[E]%
\\
\>[B]{}\F{lub}\;\Con{nil}\;\Con{nil}\;\mathrel{=}\;\Con{nil}\;\red{,}\,\;\Con{lub0}{}\<[E]%
\\
\>[B]{}\F{lub}\;(\Con{list}\;\V{t1})\;\Con{nil}\;\mathrel{=}\;\Con{list}\;\V{t1}\;\red{,}\,\;\Con{lub1}{}\<[E]%
\\
\>[B]{}\F{lub}\;(\Con{list}\;\V{t1})\;(\Con{list}\;\V{t2})\;\mathkw{with}\;\F{lub}\;\V{t1}\;\V{t2}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{t3}\;\red{,}\,\;\V{p}\;\mathrel{=}\;\Con{list}\;\V{t3}\;\red{,}\,\;\Con{lub3}\;\V{p}{}\<[E]%
\\
\>[B]{}\F{lub}\;(\Con{listcons}\;\V{t1})\;\Con{nil}\;\mathrel{=}\;\Con{list}\;\V{t1}\;\red{,}\,\;\Con{lub5}{}\<[E]%
\\
\>[B]{}\F{lub}\;(\Con{listcons}\;\V{t1})\;(\Con{list}\;\V{t2})\;\mathkw{with}\;\F{lub}\;\V{t1}\;\V{t2}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{t3}\;\red{,}\,\;\V{p}\;\mathrel{=}\;\Con{list}\;\V{t3}\;\red{,}\,\;\Con{lub2b}\;(\Con{lub3}\;\V{p}){}\<[E]%
\\
\>[B]{}\F{lub}\;(\Con{listcons}\;\V{t1})\;(\Con{listcons}\;\V{t2})\;\mathkw{with}\;\F{lub}\;\V{t1}\;\V{t2}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{t3}\;\red{,}\,\;\V{p}\;\mathrel{=}\;\Con{listcons}\;\V{t3}\;\red{,}\,\;\Con{lub7}\;\V{p}{}\<[E]%
\\
\>[B]{}\orange{\texttt{-- some code omitted for brevity}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{A definitional interpreter}\label{sec:semantics}

This section describes the steps to evaluate a program written using the list-machine language.
We adapted the small-step semantics presented in Section~\ref{sec:list}, transforming it into a
definitional interpreter~\cite{Reynolds72}, which evaluates an intrinsically-typed instruction,
transforming an initial memory state into a new one, represented by a run-time environment.


\paragraph{Values and environments}{The interpreter presented next needs to encode a run-time
environment to hold values associated to variables and their types. This way, we define the
notion of a well-typed value as follows.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Val}\;\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;\mathbin{:}\;\D{Val}\;\Con{nil}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{[]v}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{\_::\_}\;\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;\V{t}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t})\;\rightarrow\;\D{Val}\;(\Con{listcons}\;\V{t}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{\_::v\_}\;\mathbin{:}\;{}\<[11]%
\>[11]{}\D{\forall}\;\{\mskip1.5mu \V{t}\mskip1.5mu\}\;\rightarrow\;\D{Val}\;\V{t}\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t})\;\rightarrow\;\D{Val}\;(\Con{list}\;\V{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The datatype \ensuremath{\D{Val}} is indexed by a \ensuremath{\D{Ty}}, indicating the type associated to each value. The
first two represent \ensuremath{\Con{nil}} values associated with type \ensuremath{\Con{nil}} and the empty \ensuremath{\Con{list}}. The last
two represent non-empty lists, considering the types \ensuremath{\Con{listcons}} and \ensuremath{\Con{list}}.


We use the datatype \ensuremath{\D{All}} (and \ensuremath{\D{Allv}} for vectors) to define the notion of well-typed
variable environments and well-typed programs. Thus, intuitively, \ensuremath{\D{Env}} is like a
list of well-typed values. And \ensuremath{\D{PEnv}} is like a list of well-typed environments.
Both type environments are used to type block instructions and sequences of
block instructions.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{Env}\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{Env}\;\V{\Gamma}\;\mathrel{=}\;\D{All}\;(\lambda\;(\V{x}\;\red{,}\,\;\V{\tau})\;\rightarrow\;\D{Val}\;\V{\tau})\;\V{\Gamma}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\D{PEnv}\;\mathbin{:}\;\D{PCtx}\;\rightarrow\;\D{Set}{}\<[E]%
\\
\>[B]{}\D{PEnv}\;\V{\Pi}\;\mathrel{=}\;\D{Allv}\;\D{Env}\;\V{\Pi}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks





\paragraph{Fuel based evaluation}{Having all the building blocks to make the
complete interpreter for the list-machine language, we can start the definition of
the \ensuremath{\F{run\textrm{-}step}} function. It is important to note that Agda is a total language,
i.e., each program developed in it must terminate and all possible patterns must
be matched. However, by using the mechanisms for jumping between labels, one could
write a program which never ends, making it impossible to implement a terminating
interpreting function. Following the common practice, we define a fuel based
evaluator~\cite{Amin17,Owens2016}. Basically, what we do is to parameterize the
interpreter over a step index of \emph{fuel value} (represented as a natural
number $n$), which bounds the amount of work the interpreter is allowed to do,
and is decremented on each recursive call.}

The evaluation function is defined with the following type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\D{\forall}\;\{\mskip1.5mu \V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}\mskip1.5mu\}\;\rightarrow\;\D{Fuel}\;\rightarrow\;\D{Program}\;\V{\Pi}\;\rightarrow\;\D{Env}\;\V{\Gamma}\;{}\<[E]%
\\
\>[11]{}\rightarrow\;\D{Block}\;\V{\Pi}\;\V{\Gamma}\;\V{\Gamma'}\;\rightarrow\;\D{Maybe}\;(\D{Env}\;\V{\Gamma'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The function \ensuremath{\F{run\textrm{-}step}} receives four arguments and returns a \ensuremath{\D{Maybe}} value. The
first argument is the \emph{fuel}, used to ensure the evaluator always terminates.
The second parameter is a \ensuremath{\D{Program}\;\V{\Pi}}, which contains information about all the
program blocks. The third parameter is the run-time variable environment. And the
last one is the \ensuremath{\D{Block}} to be evaluated. This function returns a modified run-time
environment (\ensuremath{\D{Env}\;\V{\Gamma'}}) in case of success, or \ensuremath{\Con{nothing}} when (and only) the \emph{fuel} runs out.

From now on we describe how we implement some parts\footnote{The complete evaluation
function can be found in our online repository.} of the dynamic semantics (reduction rules)
of the list-machine language in the function \ensuremath{\F{run\textrm{-}step}}. We mix the code with the explanation
to make it easier for the reader.

\paragraph{Out of fuel}{The interpreter stops abruptly when the \emph{fuel} counter
reaches \ensuremath{\Con{zero}}, and the \ensuremath{\F{run\textrm{-}step}} function returns \ensuremath{\Con{nothing}}. This definition makes our
evaluation function structurally recursive on the \emph{fuel} argument. }

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;\Con{zero}\;\V{p}\;\V{env}\;\V{b}\;\mathrel{=}\;\Con{nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

All the next pieces of code match the value \ensuremath{\Con{suc}\;\V{fuel}} for the first argument of \ensuremath{\F{run\textrm{-}step}},
meaning that there is still \emph{fuel} during the recursive processing of this function.

%run-step (suc n) p env block-halt = just env
%run-step (suc n) p env (block-seq (instr-seq i₁ i₂) b) =
%  run-step n p env (block-seq i₁ (block-seq i₂ b))
%run-step {Π} (suc n) p env (block-seq (instr-branch-list {τ} {i} v l s) b)
%  with lookup env v
%... | []v rewrite sym ([]=⇒lookup l) =
%  run-step n p (⊂-Ctx s (update-env env v nil)) (lookupA i p)
%... | v₁ ∷v v₂ = run-step n p (update-env env v (v₁ ∷ v₂)) b
%run-step (suc n) p env (block-seq (instr-branch-listcons v l s) b) =
% run-step n p env b

\paragraph{Conditional jump}{We show next only the case when the jump actually occurs,
following the rule \emph{step-branch-taken} of \cite{Appel07}. In this case, variable \ensuremath{\V{v}} has value \ensuremath{\Con{nil}}, and
the step of evaluation should proceed with the block instruction defined in program \ensuremath{\V{p}}, with
environment \ensuremath{\V{env}} respecting the subtyping constraint. We use the function \ensuremath{\F{lookupA}} to obtain
the block instruction with index \ensuremath{\V{i}} on program \ensuremath{\V{p}}. Since we use \emph{de Bruijn} indices to
represent the label, only valid values are accepted by the intrinsically-typed syntax.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}branch\textrm{-}nil}\;\{\mskip1.5mu \V{l}\;\mathrel{=}\;\V{i}\mskip1.5mu\}\;\V{v}\;\V{l}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{rewrite}\;\D{sym}\;(\F{[]\textrm{=}{\Rightarrow}lookup}\;\V{l})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{\subset\hspace{-3pt}\textrm{-}Ctx}\;\V{s}\;\V{env})\;(\F{lookupA}\;\V{i}\;\V{p}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\paragraph{Fetching list information}{The next code shows the evaluation of two syntactical constructors,
both related to the \emph{step-fetch-field-0} rule~\cite{Appel07}. The first retrieves the head element of a list, and
stores it in a new variable. The \ensuremath{\F{lookup}} function projects the value of variable \ensuremath{\V{v}} from the run-time
environment \ensuremath{\V{env}}, and this variable is added to the result environment. The typed \emph{de Bruijn}
indices guarantee that the projected value has the type demanded, since the environment \ensuremath{\V{env}} is typed
by the context \ensuremath{\V{\Gamma}}. Similarly, the second instruction also retrieves the head element of a list, however
it needs to update the run-time environment on the position of index \ensuremath{\V{v'}}. This process is done by the
function \ensuremath{\F{update\textrm{-}env}}\footnote{The source-code of this function can be found in our online repository.}.}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;\V{v})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\V{v₁}\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\\
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;\V{v}\;\V{v'})\;\V{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathkw{with}\;\F{lookup}\;\V{env}\;\V{v}{}\<[E]%
\\
\>[B]{}\V{...|}\;\V{v₁}\;\Con{::}\;\V{v₂}\;\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;(\F{update\textrm{-}env}\;\V{env}\;\V{v'}\;\V{v₁})\;\V{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%run-step (suc n) p env (block-seq (instr-fetch-1-new v) b)
%  with lookup env v
%...| v₁ ∷ v₂ = run-step n p (v₂ ∷ env) b
%run-step (suc n) p env (block-seq (instr-fetch-1-upd v v') b)
%  with lookup env v
%...| v₁ ∷ v₂ = run-step n p (update-env env v' v₂) b

\paragraph{List creation}{To evaluate the instruction which creates a new list and respect the expected
types, we need some extra lemmas. First because when we create a list from variables \ensuremath{\V{v₀}} and \ensuremath{\V{v₁}}, the
result type of this list is the least common supertype between these two. As before, we use the \ensuremath{\F{lookup}}
function to retrieve the type information using the \emph{de Bruijn} indices of both variables, and we
extend the run-time environment \ensuremath{\V{env}} with the type of the created list. To convince the Agda's
type-checker the new environment is well-typed we use subtyping lemmas, such as \ensuremath{\F{<:\textrm{-}val}} and \ensuremath{\F{list\textrm{-}<:\textrm{-}inv}},
and others lemmas to deal with the least common supertype, such as \ensuremath{\F{lub\textrm{-}subtype\textrm{-}left}}, \ensuremath{\F{lub\textrm{-}subtype\textrm{-}right}},
and \ensuremath{\F{lub\textrm{-}of\textrm{-}subtype}}. These lemmas and their proofs can be found in our repository online. }

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{run\textrm{-}step}\;(\Con{suc}\;\V{n})\;\V{p}\;\V{env}\;(\Con{block\textrm{-}seq}\;(\Con{instr\textrm{-}cons\textrm{-}new}\;\V{v₀}\;\V{v₁}\;\V{s})\;\V{b})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\;\F{run\textrm{-}step}\;\V{n}\;\V{p}\;((\F{<:\textrm{-}val}\;(\F{list\textrm{-}<:\textrm{-}inv}\;(\F{lub\textrm{-}subtype\textrm{-}left}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\F{lub\textrm{-}of\textrm{-}subtype}\;(\F{lub\textrm{-}subtype\textrm{-}left}\;\V{s}))))\;(\F{lookup}\;\V{env}\;\V{v₀}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Con{::}\;\F{<:\textrm{-}val}\;(\F{lub\textrm{-}subtype\textrm{-}right}\;\V{s})\;(\F{lookup}\;\V{env}\;\V{v₁}))\;\Con{::}\;\V{env})\;\V{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It is worth noticing that we do not have any error treatment on this interpreter function, except for
when we ran out-of-fuel. Since we are using an intrinsically-typed syntax, only valid (well-typed) instructions
are accepted in each step of evaluation.

%run-step (suc n) p env (block-seq (instr-cons-upd v₀ v₁ v' s) b)
%  = run-step n p (update-env env v' (<:-val (list-<:-inv
%    (lub-subtype-left (lub-of-subtype (lub-subtype-left s))))
%    (lookup env v₀) ∷ <:-val (lub-subtype-right s)
%    (lookup env v₁))) b
%run-step (suc n) p env (block-jump {l = i} l s)
%  rewrite sym ([]=⇒lookup l) =
%    run-step n p (⊂-Ctx s env) (lookupA i p)

\paragraph{Soundness properties}{Programs written using an intrinsically-typed syntax are type-sound by
construction. Since only well-typed programs can be expressed, the \emph{preservation} property is
enforced by the host-language type-checker~\cite{Amin17}. By implementing the interpreter in such a
total language like Agda, i.e., specifying the dynamic semantics in a functional way, instead of
relational, we also show the \emph{progress} property, without the need for an extra proof~\cite{Owens2016}.
This approach is promising to be investigated when formalizing even more complex programming languages.}

\section{Type-Checker}\label{sec:typechecker}

In practice, a source-code of a programming language runs through several phases, including lexing, parsing,
scope checking, and most importantly \emph{type-checking}. Since we represent programs using a
intrinsically-typed syntax, scope and type-checking is only a matter of elaborating an untyped syntax
to a typed one.


Since we use \emph{de Bruijn} indices to represent labels and variables, as the first step to type and scope
check them, we need to provide an index from a named variable. This process is done by the
\ensuremath{\F{lookup\textrm{-}var}} function, returning an index when the named variable is found, and \ensuremath{\Con{nothing}} otherwise.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{lookup\textrm{-}var}\;{}\<[13]%
\>[13]{}\mathbin{:}\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\rightarrow\;(\V{x}\;\mathbin{:}\;\D{String})\;{}\<[E]%
\\
\>[13]{}\rightarrow\;\D{Maybe}\;(\D{\exists}\;\lambda\;\V{\tau}\;\rightarrow\;(\V{x}\;\red{,}\,\;\V{\tau})\;\D{\in}\;\V{\Gamma}){}\<[E]%
\\
\>[B]{}\F{lookup\textrm{-}var}\;\Con{\lbrack\:\rbrack}\;\V{x}\;\mathrel{=}\;\Con{nothing}{}\<[E]%
\\
\>[B]{}\F{lookup\textrm{-}var}\;((\V{y}\;\red{,}\,\;\V{\tau})\;\Con{::}\;\V{\Gamma})\;\V{x}\;\mathkw{with}\;\V{x}\;\D{=}\;\V{y}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{yes}\;\Con{refl}\;\mathrel{=}\;\Con{just}\;(\V{\tau}\;\red{,}\,\;\Con{here}\;\Con{refl}){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;(\Con{no}\;\V{¬p})\;\mathrel{=}\;\F{map}\;{}\<[22]%
\>[22]{}(\lambda\;\V{v}\;\rightarrow\;\D{proj_1}\;\V{v}\;\red{,}\,\;\Con{there}\;(\D{proj_2}\;\V{v}))\;{}\<[E]%
\\
\>[22]{}(\F{lookup\textrm{-}var}\;\V{\Gamma}\;\V{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks



For space reasons, we show how we type-check only one instruction\footnote{The curious reader can refer to our
online repository for a complete implementation.}. Function \ensuremath{\F{check\textrm{-}fetch\textrm{-}field\textrm{-}0}}
receives a program context, a typing context, and two named variables, and returns a \ensuremath{\D{TC}} value,
which is an error message or a \ensuremath{\D{CheckedInstr}} indicating that the term type-checks.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\F{check\textrm{-}fetch\textrm{-}field\textrm{-}0}\;\mathbin{:}\;(\V{\Pi}\;\mathbin{:}\;\D{PCtx})\;\rightarrow\;(\V{\Gamma}\;\mathbin{:}\;\D{Ctx})\;\rightarrow\;(\V{v}\;\mathbin{:}\;\D{String})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\rightarrow\;(\V{v'}\;\mathbin{:}\;\D{String})\;\rightarrow\;\D{TC}\;(\D{CheckedInstr}\;\V{\Pi}\;\V{\Gamma}\;(\Con{fetch\textrm{-}field\textrm{-}0}\;\V{v}\;\V{v'})){}\<[E]%
\\
\>[B]{}\F{check\textrm{-}fetch\textrm{-}field\textrm{-}0}\;\V{\Pi}\;\V{\Gamma}\;\V{v}\;\V{v'}\;\mathkw{with}\;\F{lookup\textrm{-}var}\;\V{\Gamma}\;\V{v}\;\red{,}\,\;\F{lookup\textrm{-}var}\;\V{\Gamma}\;\V{v'}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{nothing}\;\red{,}\,\;\anonymous \;\mathrel{=}\;\F{type\textrm{-}error}\;(\text{\ttfamily \char34 variable~out~of~scope:~\char34}\;\F{++}\;\V{v}){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{nil}\;\red{,}\,\;\anonymous )\;\red{,}\,\;\anonymous \;\mathrel{=}\;\F{type\textrm{-}error}\;\text{\ttfamily \char34 type~error~[nil]\char34}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{list}\;\V{\tau}\;\red{,}\,\;\anonymous )\;\red{,}\,\;\anonymous \;\mathrel{=}\;\F{type\textrm{-}error}\;\text{\ttfamily \char34 type~error~[list]\char34}{}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{listcons}\;\V{\tau}\;\red{,}\,\;\V{idx})\;\red{,}\,\;{}\<[34]%
\>[34]{}\Con{nothing}\;\mathrel{=}\;{}\<[E]%
\\
\>[34]{}\Con{right}\;(\Con{ok}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}new}\;\V{idx})){}\<[E]%
\\
\>[B]{}\V{...}\;\mid \;\Con{just}\;(\Con{listcons}\;\V{\tau}\;\red{,}\,\;\V{idx})\;\red{,}\,\;{}\<[34]%
\>[34]{}\Con{just}\;(\V{\tau'}\;\red{,}\,\;\V{idx'})\;\mathrel{=}\;{}\<[E]%
\\
\>[34]{}\Con{right}\;(\Con{ok}\;(\Con{instr\textrm{-}fetch\textrm{-}0\textrm{-}upd}\;\V{idx}\;\V{idx'})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the code above, we use the function \ensuremath{\F{lookup\textrm{-}var}} to provide the \emph{de Bruijn} indices for
each variable, and match the first with its possible forms. The first three cases indicate
type errors: (1) when \ensuremath{\V{v}} is \ensuremath{\Con{nothing}} it means a variable scope error; (2) and (3) are typing errors,
since the type of variable \ensuremath{\V{v}} should be a \ensuremath{\Con{listcons}}. Last two cases represent that the instruction
is well-typed. The process for type-checking different instructions follows a similar setting.

\section{Extending the Machine with Indirect Jumps}\label{sec:indirect}

In this section we describe the necessary modifications to our formalization to include indirect jumps
as proposed by Appel et. al.~\cite{AppelDL12}. We start by describing the changes on the type system
and its impact on the intrinsically typed representation of programs in Section~\ref{sec:changestypes}.
Updates on the type checker and interpreter implementations are described in Section~\ref{sec:changesintep}.

\subsection{Modifications in the type system and instruction set}

Since our solution relies on representing the program using intrinsically typed syntax, we describe
first the changes on the machine type system. The first modification is the inclusion of a type for
program labels, which denotes continuations in a program.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathkw{data}\;\D{Ty}\;\mathbin{:}\;\D{Set}\;\mathkw{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{nil}\;\Con{\top}\;\Con{\bot}\;\mathbin{:}\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{list}\;\Con{listcons}\;\mathbin{:}\;\D{Ty}\;\rightarrow\;\D{Ty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Con{cont}\;\mathbin{:}\;\D{Ctx}\;\rightarrow\;\D{Ty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The type \ensuremath{\Con{cont}} $\Gamma$ for a label express that the machine can safely jump when its registers
satisfies $\Gamma$. The inclusion of continuation types makes the type and context syntax mutually
inductive.

Since we have changed the type syntax, we need to adapt the definition of the subtyping relation.
The continuation type substantially changes the subtyping relation,
since now we have ``incomparable'' types: list types are not subtypes neither supertypes for continuations.
The solution is to complete the subtyping relation with a bottom and top types. The subtyping rules for these
new types are presented next.

\[
\begin{array}{cc}
  \infer{\bot <: \tau}{} &
  \infer{\tau <: \top}{} \\ & \\
  \multicolumn{2}{c}{
    \infer{cont\,\Gamma_1\:<:\:cont\,\Gamma_2}{\Gamma_2 \subset \Gamma_1}
  }
\end{array}
\]

We omit its representation in Agda because its just a direct encoding of these previous rules
in the subtyping relation inductive type. Notice that both subtyping relations for types and
contexts are mutually inductive.

Another major modification in the typing for the list machine is the definition of least upper bounds.
First, we complete the least upper bound relation by specifying that the lub for incomparable types is
$\top$.

\[
\begin{array}{cc}
  \infer{cont\:\Gamma\:\sqcup\:nil = \top}{} & \infer{cont\:\Gamma\:\sqcup\:(list\:\tau) = \top}\\ & \\
  \multicolumn{2}{c}{\infer{cont\:\Gamma\:\sqcup\:(listcons\:\tau) = \top}}
\end{array}
\]

We omit rules that ensure the commutativity of the least upper bound relation for brevity.
Next, we present the rules for the least upper bound relation for top and bottom types.

\[
\begin{array}{cc}
  \infer{\tau \sqcup \bot = \tau}{} & \infer{\tau \sqcup \top = \top}{}
\end{array}
\]

The last set of rules for the least upper bound relation deals with continuations.
Because of the contravariance of the \ensuremath{\Con{cont}} type, we also need to define greatest lower bounds for both
types and typing contexts. First, we present the rule for the least upper bound for continuation types.

\[
\begin{array}{c}
  \infer{cont\:\Gamma_1\:\sqcap\: cont\:\Gamma_2=cont\:\Gamma_3}{\Gamma_1\cup\Gamma_2 = \Gamma_3}
\end{array}
\]

The rule specifies that the least upper bound for types \ensuremath{\Con{cont}} $\Gamma_1$ and \ensuremath{\Con{cont}} $\Gamma_2$ is
\ensuremath{\Con{cont}} $\Gamma_3$, where $\Gamma_3$ is greatest lower bound for typing contexts $\Gamma_1$ and $\Gamma_2$.
The definition of the greatest lower bound for contexts is presented next.
\[
  \begin{array}{cc}
    \infer{\{\} \cup \Gamma = \Gamma}{} &
    \infer{\Gamma \cup \{\} = \Gamma}{} \\ & \\
    \multicolumn{2}{c}{
      \infer{(\Gamma_1 , x : \tau_1) \cup (\Gamma_2 , x : t_2) = \Gamma_3, x : \tau_3}
            {\tau_1 \sqcup \tau_2 = \tau_3 & \Gamma_1 \cup \Gamma_2 = \Gamma_3}
    }
  \end{array}
\]
The definition of the greatest lower bound for types is as follows. The first set of rules specify the reflexivity,
that $`\top$ type is an identity and $`\bot$ is for greastest lower bound for any type $\tau$.
Again, rules to ensure commutativity of the relation are ommited for brevity.

\[
\begin{array}{ccc}
  \infer{\tau \sqcup \tau = \tau}{} & \infer{\top \sqcup \tau = \tau}{} & \infer{\bot \sqcup \tau = \bot}{}\\
\end{array}
\]
Next, we define the greatest lower bound relation for list types. The first rule specifies that the bottom
type is the greatest lower bound for the empty list type and non-empty list type. Two rules specifies the
compatibility of \ensuremath{\Con{list}} and \ensuremath{\Con{listcons}} type constructors with the greatest lower bound relation. The last
rule show that \ensuremath{\Con{listcons}} $\tau_3$ is the lower bound for \ensuremath{\Con{list}} $\tau_1$ and \ensuremath{\Con{listcons}} $\tau_2$.
\[
\begin{array}{cc}
  \infer{nil \sqcup (listcons\: \tau) = \bot}{} &
  \infer{(list\: \tau_1)\sqcup (list\:\tau_2) = list\:\tau_3}{\tau_1\sqcup \tau_2 = \tau_3} \\ & \\
   \infer{(listcons\: \tau_1)\sqcup (listcons\:\tau_2) = listcons\:\tau_3}{\tau_1\sqcup \tau_2 = \tau_3} &
  \infer{(list\: \tau_1)\sqcup (listcons\:\tau_2) = listcons\:\tau_3}{\tau_1\sqcup \tau_2 = \tau_3} \\ & \\
\end{array}
\]
Rules for the greatest lower bound relation for continuation types shows that bottom type is the
lower bound for list types and continuation one. The other rule for stabishes the compatibility of
the continuation type with the lower bound relation and it uses the least upper bound for typing
contexts relation.
\[
\begin{array}{ccc}
  \infer{nil\sqcup(cont\:\Gamma) = \bot}{} &
  \infer{(list\:\tau)\sqcup(cont\:\Gamma) = \bot}{} &
  \infer{(listcons\:\tau)\sqcup(cont\:\Gamma) = \bot}{} \\ & & \\
  \multicolumn{3}{c}{
    \infer{(cont\:\Gamma_1)\sqcup(cont\:\Gamma_2) = (cont\:\Gamma_3)}{\Gamma_1\cap\Gamma_2 = \Gamma_3}
  }
\end{array}
\]
We omit several rules for the greatest lower bound relation that ensure the commutativity of the
relation and that $\bot$ type is a lower bound for any type. Rules for the least upper bound for
typing contexts are simply the dual version for greatest lower bound for contexts, as shown next.
\[
  \begin{array}{cc}
    \infer{\{\} \cap \Gamma = \{\}}{} &
    \infer{\Gamma \cap \{\} = \{\}}{} \\ & \\
    \multicolumn{2}{c}{
      \infer{(\Gamma_1 , x : \tau_1) \cap (\Gamma_2 , x : t_2) = \Gamma_3, x : \tau_3}
            {\tau_1 \sqcap \tau_2 = \tau_3 & \Gamma_1 \cap \Gamma_2 = \Gamma_3}
    }
  \end{array}
\]
The Agda encoding of these relations is an immediate translation of the mathematical notation
to code and are omitted for brevity.

\subsection{Modifications in the type-checker and interpreter}\label{sec:changesintep}


\section{Comparison of Mechanized Proofs}\label{sec:comparison}

We implemented all 14 tasks from the list-machine benchmark in the Agda programming language.
The tasks considered by us are the same implemented and proved by Appel et. al.~\cite{Appel07}.
The next table summarizes the total number of lines of code (LOC) for our results together with theirs.

\begin{table}[!htb]
\begin{tabular}{rl|rrr}
    & Task                                         & \multicolumn{1}{l}{Twelf} & \multicolumn{1}{l}{Coq} & \multicolumn{1}{l}{Agda} \\ \hline
1.  & Operational Semantics                        & 126                       & 98                      & 109                      \\
2.  & Derive $p \Downarrow$                        & 1                         & 8                       & 1                        \\ \hline
3.  & Type System $\vDash_{\textrm{prog}} p : \Pi$ & 167                       & 130                     & 62                       \\
4.  & $\sqcap$ algorithm                           & *                         & *                       & 13                       \\
5.  & Derive $\vDash_{\textrm{prog}} p_{\textrm{sample}} : \Pi_{\textrm{sample}}$
                                                   & 1                         & no                      & 1                        \\
6.  & State properties of $\sqcap$                 & 12                        & 13                      & 6                        \\
7.  & Prove properties of $\sqcap$                 & 114                       & 21                      & 124                      \\
8.  & State soundness theorem                      & 29                        & 15                      & *                        \\
9.  & Prove soundness of $\vDash_{\textrm{prog}} p : \Pi$
                                                   & 2060                      & 315                     & *                        \\ \hline
10. & Efficient algorithm                          & 22                        & 145                     & 98                       \\
11. & Derive $\vdash_{\textrm{prog}} p_{\textrm{sample}} : \Pi_{\textrm{sample}}$
                                                   & 1                         & 1                       & 1                        \\
12. & Prove termination of $\vdash_{\textrm{prog}} p : \Pi$
                                                   & 18                        & 0                       & 0                        \\
13. & Scalable type-checker                        & yes                       & yes                     & yes                      \\
14. & Prove soundness of $\vdash_{\textrm{prog}} p : \Pi$
                                                   & 347                       & 141                     & *
\end{tabular}
\end{table}

The total time for parsing and proof checking our Agda implementation was around 10 seconds
on a machine with a Intel Core I7 1.7 GHz, 8GB RAM running Mac OS X 10.15.5. We briefly comment
on our Agda encoding of these 14 tasks.

\begin{enumerate}
  \item \textbf{Operational semantics.} Instead of using an inductive type for representing the operational semantics, we chose to
        use a definitional interpreter for our intrinsically-typed representation. Our implementation for the operational
        semantics is composed by 38 lines for the typed syntax and 71 for the definitional interpreter.
  \item \textbf{Derive $p \Downarrow$.} Since we used a definitional interpreter for representing the semantics, we can derive
        $p\,\Downarrow$ just by executing the interpreter on $p$.
  \item \textbf{Represent the type system.} Our type system representation consists of the intrinsically-typed encoding of
        the list-machine programs and it is already counted in as part of the operational semantics of our solution.
      \item \textbf{Least common supertype algorithm.} In order to implement this task, we specified the least common super type
        as a relation and implemented the algorithm which shows that this relation is indeed a function. In this way, we
        guarantee its soundness w.r.t. its specification.
  \item \textbf{Derive an example of type-checking.} Our approach to build a derivation for a sample list-machine program
        is just to execute the type-checker over it. Since our type-checker returns an intrinsically-typed representation of
        the input and such typed syntax is equivalent to the type system, it can be used to build type derivations.
  \item \textbf{State properties of the least common supertype.} This is trivial, since it is just a matter to encode the
        desired properties as Agda function types.
  \item \textbf{Prove properties of the least common supertype.} Proofs of all proved properties about the least common supertype
        are simple recursive functions over the least common supertype and subtyping relations definitions and were omitted
        from this text for space reasons.
  \item \textbf{State the soundness theorem for the type system.} Following~\cite{Amin17}, we represent the soundness
        theorem statement as the type of our definitional interpreter for the intrinsically-typed syntax for the list-machine
        programs. Therefore, this was done as part of task 9.
  \item \textbf{Prove the soundness theorem for the type system.} Following \cite{Amin17}, the proof of the soundness
        theorem is just the implementation of the definitional interpreter. Soundness is ensured by construction since the interpreter
        produces, as result, an environment of well-typed values resulting from the execution of the input program.
  \item \textbf{Asymptotically efficient algorithm.} Our current implementation of the type-checker takes quadratic time. The reason
        for this inefficiency is the representation of environments as lists / vectors. The use of better data structures (like finite
        maps implemented by efficient search trees) can solve this issue. We leave this fix to future work.
  \item \textbf{Simulate the new algorithm.} This task is just one line of code, since it is only a matter of calling the type-checker
        on the input program.
  \item \textbf{Prove the termination of the type-checker.} This task is trivial in our setting, since all defined Agda functions
        must be total. The totality is ensured by Agda's termination / totality checker.
  \item \textbf{Scalable type-checker.} Agda code can be compiled to machine code using its GHC-Haskell back-end. Since GHC is
        an industrial strength compiler, the back-end can generate an efficient executable for the machine interpreter and type-checker.
  \item \textbf{Prove soundness of type-checker.} In our approach, the soundness of the type-checker is ensured by construction,
        since it returns the intrinsically-typed representation of the input program which corresponds to its typing derivation.
\end{enumerate}

As we could notice, our approach avoids code repetition and decreases the needed LOCs, when compared to Appel et. al.
\cite{Appel07} solution.
Our implementation used 415 LOC to complete the tasks, while the Twelf solution demanded 2898 LOC and 887 LOC in Coq.
Our encoding uses approximately 14\% of the LOC when compared to the Twelf formalization, and 47\% when compared to Coq's. The main
reason for this difference is that our intrinsically-typed syntax granted us many properties for free (e.g. type soundness).

%As we could notice on the previous table, the approach taken in this paper avoids code repetition and decreases the number of LOCs necessary to
%implement the proposed language and to prove its properties. The formalization of this benchmark took 2898 LOC to be done in Twelf, and 887 LOC
%in Coq, while our implementation used only 415 LOC to achieve the same result. Our encoding uses approximately 14\% of the LOC when compared to
%the Twelf formalization, and 47\% when compared to Coq's. The main reason for this difference is the fact that the soundness properties are
%obtained for free when combining an intrinsically-typed syntax with an implementation of a definitional interpreter in a total language like Agda.

\section{Related work}\label{sec:related}

\paragraph{Benchmarks for PL mechanization}{
The importance of benchmarks is recognized in several areas in computer science. A relevant example is the
TPTP library for the theorem proving community~\cite{Sut17}. In the context of the programming languages community,
we have the POPLMark challenge~\cite{Aydemir05}, which was developed by a renowned group of programming language researchers aiming
at the collaboration between the PL community and the proof assistants researchers. The main objective of this challenge
was to motivate authors to formalize all of their theorems using such tools. Since the focus of the POPLMark challenge
was mainly the formalization of type soundness theorems, other benchmarks were proposed with different objectives. The list
machine benchmark was proposed by~\citet{Appel07} as an exercise in formalizing results that interest
compiler oriented research and also provides Twelf and Coq solutions to this benchmark. Our work provides another
solution to this benchmark using an intrinsically-typed approach in the Agda programming language. Representation of binding syntax
was the subject of~\citet{FeltyMP18} which proposed a set of problems and research questions for tools
that use the high-order abstract syntax approach for name binding. Since the list-machine benchmark definition avoids
name binding issues because they are orthogonal to most of compiler related proofs~\cite{Appel07}, we just ensure
the correct manipulation of names by following the traditional \emph{de Bruijn} approach. Finally, a recent problem set
was proposed by~\citet{Pientka18}, named POPLMark challenge reloaded, focusing on the mechanization
of logical relation arguments, like strong normalization theorems.}

\paragraph{Definitional interpreters}{
The use of definitional interpreters for specifying semantics dates back to Reynold's pioneer work~\cite{Reynolds72}.
Recently, the interest on such interpreters was revitalized by~\citet{Amin17}, which used definitional
interpreters, implemented in Coq, to prove type soundness theorems for non-trivial typed languages like System F$_{<:}$.
Unlike our work, Amin and Rompf's formalizations do not use intrinsically-typed representations of their syntax, what cluttered
their formalization with the need of dealing with ``stuck states'' in the semantics. \citet{Poulsen18} described how
definitional interpreters for imperative languages can be much concisely implemented by using intrinsically-typed syntax and a
library for name binding using \emph{scope graphs}, which greatly simplifies the treatment of complex
binding structures. Since the list-machine benchmark was designed to address other problems than binding, our representation
using \emph{de Bruijn} indices was sufficient to implement the desired type-checker and interpreter.
Other recent application of definitional interpreters was proposed by~\citet{Rouvoet20}. The main contribution
of Rouvoet et. al. was to define interpreters for linear typed languages supporting session based concurrency. In order to model
linear typing features in the interpreter, the authors have implemented monads based on a separation algebra which they
named \emph{Market}, supporting the main operations for accessing and updating the store used by the interpreter.
Another work using intrinsically-typed syntax for resource control was developed by~\citet{Thiemann19}, which
implemented an interpreter for a more realistic core functional session typed calculus including recursion and
session subtyping in Agda. Thiemann modeled the semantics as an interruptible abstract machine which provides a
simple interface to a scheduler. Since our objective was to formalize the list-machine benchmark in Agda and it
does not have linearity constraints in its state manipulation, we do not need to deal with the complexities
of linear and session types as in~\cite{Rouvoet20,Thiemann19}. A formalization of System F$_{\omega\mu}$ was
the subject of \citet{ChapmanKNW19} work, which used an intrinsically-typed representation to
implement a normalization by evaluation for this calculus. The reason behind such formalization effort was
the verification of a core language for smart-contracts which is based on System F$_{\omega\mu}$. As our work,
Chapman's et al. formalization is an example of how intrisincally-typed syntax leads to clear interpreter code
which avoids completely stuck states.}

\vspace{-3ex}

\section{Conclusion}\label{sec:conclusion}

This paper shows how the combination of intrinsically-typed syntax and definitional interpreters can be used to simplify
the tasks on the formalization of programming languages. Using such approach, we were able to provide a machine-checked version of the
list-machine benchmark in Agda, showing that the approach is useful to formalize both high-level and low-level languages.
The ideas presented here can be exploited on the formalization of real-world virtual machines, such as the JVM and LUA VM,
since we were able to encode features such as jumps, mutable state, and sub-typing. When comparing our work with the
conventional non-dependently typed formalization strategies (like the one used by \citet{Appel07} in their Coq and Twelf implementations),
we can affirm that it requires a fewer number of lines to achieve the same result, even without the use of proof automation.
This happens because the approach uses the power of the host language, and provides some proofs for free due to the
intrinsically-typed syntax.

As future work, we want to reuse the ideas presented in this paper to provide an intrinsically-typed formalization for
real-world low-level languages like the eBPF and the LUA VM. Furthermore, one can extend the formalization presented here
for other programming languages with similar settings.

\bibliography{main}

\end{document}
